#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Mon Mar 17 20:27:38 2014 by generateDS.py version 2.12b.
#

import sys
import getopt
import re as re_
import base64
import datetime as datetime_

etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = list(range(3))
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, str) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, str) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class emptyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, all=None):
        self.all = _cast(float, all)
        pass
    def factory(*args_, **kwargs_):
        if emptyType.subclass:
            return emptyType.subclass(*args_, **kwargs_)
        else:
            return emptyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_all(self): return self.all
    def set_all(self, all): self.all = all
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='emptyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='emptyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='emptyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='emptyType'):
        if self.all is not None and 'all' not in already_processed:
            already_processed.add('all')
            outfile.write(' all="%s"' % self.gds_format_double(self.all, input_name='all'))
    def exportChildren(self, outfile, level, namespace_='', name_='emptyType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='emptyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.all is not None and 'all' not in already_processed:
            already_processed.add('all')
            showIndent(outfile, level)
            outfile.write('all=%e,\n' % (self.all,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('all', node)
        if value is not None and 'all' not in already_processed:
            already_processed.add('all')
            try:
                self.all = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (all): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class emptyType


class pluginDef(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, plugin=None, valueOf_=None):
        self.plugin = _cast(None, plugin)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if pluginDef.subclass:
            return pluginDef.subclass(*args_, **kwargs_)
        else:
            return pluginDef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_plugin(self): return self.plugin
    def set_plugin(self, plugin): self.plugin = plugin
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_pluginType(self, value):
        # Validate type pluginType, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='pluginDef', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pluginDef')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='pluginDef', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='pluginDef'):
        if self.plugin is not None and 'plugin' not in already_processed:
            already_processed.add('plugin')
            outfile.write(' plugin=%s' % (quote_attrib(self.plugin), ))
    def exportChildren(self, outfile, level, namespace_='', name_='pluginDef', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='pluginDef'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.plugin is not None and 'plugin' not in already_processed:
            already_processed.add('plugin')
            showIndent(outfile, level)
            outfile.write('plugin="%s",\n' % (self.plugin,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('plugin', node)
        if value is not None and 'plugin' not in already_processed:
            already_processed.add('plugin')
            self.plugin = value
            self.validate_pluginType(self.plugin)    # validate type pluginType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class pluginDef


class vector(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vectorSize=1, vectorFile=None, all=False, vectorPlugin=None, valueOf_=None):
        self.vectorSize = _cast(int, vectorSize)
        self.vectorFile = _cast(None, vectorFile)
        self.all = _cast(bool, all)
        self.vectorPlugin = _cast(None, vectorPlugin)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if vector.subclass:
            return vector.subclass(*args_, **kwargs_)
        else:
            return vector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vectorSize(self): return self.vectorSize
    def set_vectorSize(self, vectorSize): self.vectorSize = vectorSize
    def get_vectorFile(self): return self.vectorFile
    def set_vectorFile(self, vectorFile): self.vectorFile = vectorFile
    def get_all(self): return self.all
    def set_all(self, all): self.all = all
    def get_vectorPlugin(self): return self.vectorPlugin
    def set_vectorPlugin(self, vectorPlugin): self.vectorPlugin = vectorPlugin
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_pluginType(self, value):
        # Validate type pluginType, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='vector', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vector')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='vector', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vector'):
        if self.vectorSize is not None and 'vectorSize' not in already_processed:
            already_processed.add('vectorSize')
            outfile.write(' vectorSize="%s"' % self.gds_format_integer(self.vectorSize, input_name='vectorSize'))
        if self.vectorFile is not None and 'vectorFile' not in already_processed:
            already_processed.add('vectorFile')
            outfile.write(' vectorFile=%s' % (self.gds_format_string(quote_attrib(self.vectorFile).encode(ExternalEncoding), input_name='vectorFile'), ))
        if self.all is not None and 'all' not in already_processed:
            already_processed.add('all')
            outfile.write(' all="%s"' % self.gds_format_boolean(self.all, input_name='all'))
        if self.vectorPlugin is not None and 'vectorPlugin' not in already_processed:
            already_processed.add('vectorPlugin')
            outfile.write(' vectorPlugin=%s' % (quote_attrib(self.vectorPlugin), ))
    def exportChildren(self, outfile, level, namespace_='', name_='vector', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='vector'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vectorSize is not None and 'vectorSize' not in already_processed:
            already_processed.add('vectorSize')
            showIndent(outfile, level)
            outfile.write('vectorSize=%d,\n' % (self.vectorSize,))
        if self.vectorFile is not None and 'vectorFile' not in already_processed:
            already_processed.add('vectorFile')
            showIndent(outfile, level)
            outfile.write('vectorFile="%s",\n' % (self.vectorFile,))
        if self.all is not None and 'all' not in already_processed:
            already_processed.add('all')
            showIndent(outfile, level)
            outfile.write('all=%s,\n' % (self.all,))
        if self.vectorPlugin is not None and 'vectorPlugin' not in already_processed:
            already_processed.add('vectorPlugin')
            showIndent(outfile, level)
            outfile.write('vectorPlugin="%s",\n' % (self.vectorPlugin,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vectorSize', node)
        if value is not None and 'vectorSize' not in already_processed:
            already_processed.add('vectorSize')
            try:
                self.vectorSize = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.vectorSize < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('vectorFile', node)
        if value is not None and 'vectorFile' not in already_processed:
            already_processed.add('vectorFile')
            self.vectorFile = value
        value = find_attr_value_('all', node)
        if value is not None and 'all' not in already_processed:
            already_processed.add('all')
            if value in ('true', '1'):
                self.all = True
            elif value in ('false', '0'):
                self.all = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('vectorPlugin', node)
        if value is not None and 'vectorPlugin' not in already_processed:
            already_processed.add('vectorPlugin')
            self.vectorPlugin = value
            self.validate_pluginType(self.vectorPlugin)    # validate type pluginType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class vector


class matrix(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, matrixColSize=None, matrixFile=None, matrixPlugin=None, matrixRowSize=None, row=None):
        self.matrixColSize = _cast(int, matrixColSize)
        self.matrixFile = _cast(None, matrixFile)
        self.matrixPlugin = _cast(None, matrixPlugin)
        self.matrixRowSize = _cast(int, matrixRowSize)
        if row is None:
            self.row = []
        else:
            self.row = row
    def factory(*args_, **kwargs_):
        if matrix.subclass:
            return matrix.subclass(*args_, **kwargs_)
        else:
            return matrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_row(self): return self.row
    def set_row(self, row): self.row = row
    def add_row(self, value): self.row.append(value)
    def insert_row(self, index, value): self.row[index] = value
    def get_matrixColSize(self): return self.matrixColSize
    def set_matrixColSize(self, matrixColSize): self.matrixColSize = matrixColSize
    def get_matrixFile(self): return self.matrixFile
    def set_matrixFile(self, matrixFile): self.matrixFile = matrixFile
    def get_matrixPlugin(self): return self.matrixPlugin
    def set_matrixPlugin(self, matrixPlugin): self.matrixPlugin = matrixPlugin
    def get_matrixRowSize(self): return self.matrixRowSize
    def set_matrixRowSize(self, matrixRowSize): self.matrixRowSize = matrixRowSize
    def validate_doubleList(self, value):
        # Validate type doubleList, a restriction on xsd:double.
        pass
    def validate_pluginType(self, value):
        # Validate type pluginType, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (
            self.row
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='matrix', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='matrix')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='matrix', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='matrix'):
        if self.matrixColSize is not None and 'matrixColSize' not in already_processed:
            already_processed.add('matrixColSize')
            outfile.write(' matrixColSize="%s"' % self.gds_format_integer(self.matrixColSize, input_name='matrixColSize'))
        if self.matrixFile is not None and 'matrixFile' not in already_processed:
            already_processed.add('matrixFile')
            outfile.write(' matrixFile=%s' % (self.gds_format_string(quote_attrib(self.matrixFile).encode(ExternalEncoding), input_name='matrixFile'), ))
        if self.matrixPlugin is not None and 'matrixPlugin' not in already_processed:
            already_processed.add('matrixPlugin')
            outfile.write(' matrixPlugin=%s' % (quote_attrib(self.matrixPlugin), ))
        if self.matrixRowSize is not None and 'matrixRowSize' not in already_processed:
            already_processed.add('matrixRowSize')
            outfile.write(' matrixRowSize="%s"' % self.gds_format_integer(self.matrixRowSize, input_name='matrixRowSize'))
    def exportChildren(self, outfile, level, namespace_='', name_='matrix', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for row_ in self.row:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srow>%s</%srow>%s' % (namespace_, self.gds_format_double_list(row_, input_name='row'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='matrix'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.matrixColSize is not None and 'matrixColSize' not in already_processed:
            already_processed.add('matrixColSize')
            showIndent(outfile, level)
            outfile.write('matrixColSize=%d,\n' % (self.matrixColSize,))
        if self.matrixFile is not None and 'matrixFile' not in already_processed:
            already_processed.add('matrixFile')
            showIndent(outfile, level)
            outfile.write('matrixFile="%s",\n' % (self.matrixFile,))
        if self.matrixPlugin is not None and 'matrixPlugin' not in already_processed:
            already_processed.add('matrixPlugin')
            showIndent(outfile, level)
            outfile.write('matrixPlugin="%s",\n' % (self.matrixPlugin,))
        if self.matrixRowSize is not None and 'matrixRowSize' not in already_processed:
            already_processed.add('matrixRowSize')
            showIndent(outfile, level)
            outfile.write('matrixRowSize=%d,\n' % (self.matrixRowSize,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('row=[\n')
        level += 1
        for row_ in self.row:
            showIndent(outfile, level)
            outfile.write('%e,\n' % row_)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('matrixColSize', node)
        if value is not None and 'matrixColSize' not in already_processed:
            already_processed.add('matrixColSize')
            try:
                self.matrixColSize = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.matrixColSize < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('matrixFile', node)
        if value is not None and 'matrixFile' not in already_processed:
            already_processed.add('matrixFile')
            self.matrixFile = value
        value = find_attr_value_('matrixPlugin', node)
        if value is not None and 'matrixPlugin' not in already_processed:
            already_processed.add('matrixPlugin')
            self.matrixPlugin = value
            self.validate_pluginType(self.matrixPlugin)    # validate type pluginType
        value = find_attr_value_('matrixRowSize', node)
        if value is not None and 'matrixRowSize' not in already_processed:
            already_processed.add('matrixRowSize')
            try:
                self.matrixRowSize = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.matrixRowSize < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'row':
            row_ = child_.text
            row_ = self.gds_validate_double_list(row_, node, 'row')
            self.row.append(row_.split())
            self.validate_doubleList(self.row)    # validate type doubleList
# end class matrix


class listOfMatrices(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, number=None, matrix=None):
        self.number = _cast(int, number)
        if matrix is None:
            self.matrix = []
        else:
            self.matrix = matrix
    def factory(*args_, **kwargs_):
        if listOfMatrices.subclass:
            return listOfMatrices.subclass(*args_, **kwargs_)
        else:
            return listOfMatrices(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_matrix(self): return self.matrix
    def set_matrix(self, matrix): self.matrix = matrix
    def add_matrix(self, value): self.matrix.append(value)
    def insert_matrix(self, index, value): self.matrix[index] = value
    def get_number(self): return self.number
    def set_number(self, number): self.number = number
    def hasContent_(self):
        if (
            self.matrix
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='listOfMatrices', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='listOfMatrices')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='listOfMatrices', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='listOfMatrices'):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
    def exportChildren(self, outfile, level, namespace_='', name_='listOfMatrices', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for matrix_ in self.matrix:
            matrix_.export(outfile, level, namespace_, name_='matrix', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='listOfMatrices'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            showIndent(outfile, level)
            outfile.write('number=%d,\n' % (self.number,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('matrix=[\n')
        level += 1
        for matrix_ in self.matrix:
            showIndent(outfile, level)
            outfile.write('model_.matrix(\n')
            matrix_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            try:
                self.number = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.number < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'matrix':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.matrix.append(obj_)
# end class listOfMatrices


class matrixData(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, matrixColSize=None, matrixRowSize=None, row=None):
        self.matrixColSize = _cast(int, matrixColSize)
        self.matrixRowSize = _cast(int, matrixRowSize)
        if row is None:
            self.row = []
        else:
            self.row = row
    def factory(*args_, **kwargs_):
        if matrixData.subclass:
            return matrixData.subclass(*args_, **kwargs_)
        else:
            return matrixData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_row(self): return self.row
    def set_row(self, row): self.row = row
    def add_row(self, value): self.row.append(value)
    def insert_row(self, index, value): self.row[index] = value
    def get_matrixColSize(self): return self.matrixColSize
    def set_matrixColSize(self, matrixColSize): self.matrixColSize = matrixColSize
    def get_matrixRowSize(self): return self.matrixRowSize
    def set_matrixRowSize(self, matrixRowSize): self.matrixRowSize = matrixRowSize
    def validate_doubleList(self, value):
        # Validate type doubleList, a restriction on xsd:double.
        pass
    def hasContent_(self):
        if (
            self.row
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='matrixData', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='matrixData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='matrixData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='matrixData'):
        if self.matrixColSize is not None and 'matrixColSize' not in already_processed:
            already_processed.add('matrixColSize')
            outfile.write(' matrixColSize="%s"' % self.gds_format_integer(self.matrixColSize, input_name='matrixColSize'))
        if self.matrixRowSize is not None and 'matrixRowSize' not in already_processed:
            already_processed.add('matrixRowSize')
            outfile.write(' matrixRowSize="%s"' % self.gds_format_integer(self.matrixRowSize, input_name='matrixRowSize'))
    def exportChildren(self, outfile, level, namespace_='', name_='matrixData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for row_ in self.row:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srow>%s</%srow>%s' % (namespace_, self.gds_format_double_list(row_, input_name='row'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='matrixData'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.matrixColSize is not None and 'matrixColSize' not in already_processed:
            already_processed.add('matrixColSize')
            showIndent(outfile, level)
            outfile.write('matrixColSize=%d,\n' % (self.matrixColSize,))
        if self.matrixRowSize is not None and 'matrixRowSize' not in already_processed:
            already_processed.add('matrixRowSize')
            showIndent(outfile, level)
            outfile.write('matrixRowSize=%d,\n' % (self.matrixRowSize,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('row=[\n')
        level += 1
        for row_ in self.row:
            showIndent(outfile, level)
            outfile.write('%e,\n' % row_)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('matrixColSize', node)
        if value is not None and 'matrixColSize' not in already_processed:
            already_processed.add('matrixColSize')
            try:
                self.matrixColSize = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.matrixColSize < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('matrixRowSize', node)
        if value is not None and 'matrixRowSize' not in already_processed:
            already_processed.add('matrixRowSize')
            try:
                self.matrixRowSize = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.matrixRowSize < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'row':
            row_ = child_.text
            row_ = self.gds_validate_double_list(row_, node, 'row')
            self.row.append(row_)
            self.row = self.row.split()
            self.validate_doubleList(self.row)    # validate type doubleList
# end class matrixData


class matrixPlugin(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, matrixPlugin=None):
        self.matrixPlugin = _cast(None, matrixPlugin)
        pass
    def factory(*args_, **kwargs_):
        if matrixPlugin.subclass:
            return matrixPlugin.subclass(*args_, **kwargs_)
        else:
            return matrixPlugin(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_matrixPlugin(self): return self.matrixPlugin
    def set_matrixPlugin(self, matrixPlugin): self.matrixPlugin = matrixPlugin
    def validate_pluginType(self, value):
        # Validate type pluginType, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='matrixPlugin', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='matrixPlugin')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='matrixPlugin', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='matrixPlugin'):
        if self.matrixPlugin is not None and 'matrixPlugin' not in already_processed:
            already_processed.add('matrixPlugin')
            outfile.write(' matrixPlugin=%s' % (quote_attrib(self.matrixPlugin), ))
    def exportChildren(self, outfile, level, namespace_='', name_='matrixPlugin', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='matrixPlugin'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.matrixPlugin is not None and 'matrixPlugin' not in already_processed:
            already_processed.add('matrixPlugin')
            showIndent(outfile, level)
            outfile.write('matrixPlugin="%s",\n' % (self.matrixPlugin,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('matrixPlugin', node)
        if value is not None and 'matrixPlugin' not in already_processed:
            already_processed.add('matrixPlugin')
            self.matrixPlugin = value
            self.validate_pluginType(self.matrixPlugin)    # validate type pluginType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class matrixPlugin


class matrixFile(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, matrixFile=None):
        self.matrixFile = _cast(None, matrixFile)
        pass
    def factory(*args_, **kwargs_):
        if matrixFile.subclass:
            return matrixFile.subclass(*args_, **kwargs_)
        else:
            return matrixFile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_matrixFile(self): return self.matrixFile
    def set_matrixFile(self, matrixFile): self.matrixFile = matrixFile
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='matrixFile', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='matrixFile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='matrixFile', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='matrixFile'):
        if self.matrixFile is not None and 'matrixFile' not in already_processed:
            already_processed.add('matrixFile')
            outfile.write(' matrixFile=%s' % (self.gds_format_string(quote_attrib(self.matrixFile).encode(ExternalEncoding), input_name='matrixFile'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='matrixFile', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='matrixFile'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.matrixFile is not None and 'matrixFile' not in already_processed:
            already_processed.add('matrixFile')
            showIndent(outfile, level)
            outfile.write('matrixFile="%s",\n' % (self.matrixFile,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('matrixFile', node)
        if value is not None and 'matrixFile' not in already_processed:
            already_processed.add('matrixFile')
            self.matrixFile = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class matrixFile


class memory(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sizeMax=None, Memory=None):
        self.sizeMax = _cast(int, sizeMax)
        if Memory is None:
            self.Memory = []
        else:
            self.Memory = Memory
    def factory(*args_, **kwargs_):
        if memory.subclass:
            return memory.subclass(*args_, **kwargs_)
        else:
            return memory(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Memory(self): return self.Memory
    def set_Memory(self, Memory): self.Memory = Memory
    def add_Memory(self, value): self.Memory.append(value)
    def insert_Memory(self, index, value): self.Memory[index] = value
    def get_sizeMax(self): return self.sizeMax
    def set_sizeMax(self, sizeMax): self.sizeMax = sizeMax
    def hasContent_(self):
        if (
            self.Memory
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='memory', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='memory')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='memory', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='memory'):
        if self.sizeMax is not None and 'sizeMax' not in already_processed:
            already_processed.add('sizeMax')
            outfile.write(' sizeMax="%s"' % self.gds_format_integer(self.sizeMax, input_name='sizeMax'))
    def exportChildren(self, outfile, level, namespace_='', name_='memory', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Memory_ in self.Memory:
            Memory_.export(outfile, level, namespace_, name_='Memory', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='memory'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sizeMax is not None and 'sizeMax' not in already_processed:
            already_processed.add('sizeMax')
            showIndent(outfile, level)
            outfile.write('sizeMax=%d,\n' % (self.sizeMax,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Memory=[\n')
        level += 1
        for Memory_ in self.Memory:
            showIndent(outfile, level)
            outfile.write('model_.vector(\n')
            Memory_.exportLiteral(outfile, level, name_='vector')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sizeMax', node)
        if value is not None and 'sizeMax' not in already_processed:
            already_processed.add('sizeMax')
            try:
                self.sizeMax = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.sizeMax < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Memory':
            obj_ = vector.factory()
            obj_.build(child_)
            self.Memory.append(obj_)
# end class memory


class ModelTime(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, t=None, t0=None, T=None):
        self.t = t
        self.t0 = t0
        self.T = T
    def factory(*args_, **kwargs_):
        if ModelTime.subclass:
            return ModelTime.subclass(*args_, **kwargs_)
        else:
            return ModelTime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_t(self): return self.t
    def set_t(self, t): self.t = t
    def get_t0(self): return self.t0
    def set_t0(self, t0): self.t0 = t0
    def get_T(self): return self.T
    def set_T(self, T): self.T = T
    def validate_positiveDouble(self, value):
        # Validate type positiveDouble, a restriction on xsd:double.
        pass
    def hasContent_(self):
        if (
            self.t is not None or
            self.t0 is not None or
            self.T is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ModelTime', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ModelTime')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ModelTime', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ModelTime'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ModelTime', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.t is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%st>%s</%st>%s' % (namespace_, self.gds_format_double(self.t, input_name='t'), namespace_, eol_))
        if self.t0 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%st0>%s</%st0>%s' % (namespace_, self.gds_format_double(self.t0, input_name='t0'), namespace_, eol_))
        if self.T is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sT>%s</%sT>%s' % (namespace_, self.gds_format_double(self.T, input_name='T'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ModelTime'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.t is not None:
            showIndent(outfile, level)
            outfile.write('t=%e,\n' % self.t)
        if self.t0 is not None:
            showIndent(outfile, level)
            outfile.write('t0=%e,\n' % self.t0)
        if self.T is not None:
            showIndent(outfile, level)
            outfile.write('T=%e,\n' % self.T)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 't':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 't')
            self.t = fval_
            self.validate_positiveDouble(self.t)    # validate type positiveDouble
        elif nodeName_ == 't0':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 't0')
            self.t0 = fval_
            self.validate_positiveDouble(self.t0)    # validate type positiveDouble
        elif nodeName_ == 'T':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'T')
            self.T = fval_
            self.validate_positiveDouble(self.T)    # validate type positiveDouble
# end class ModelTime


class BoundaryCondition(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Linear=None, NLinear=None, Periodic=None):
        self.Linear = Linear
        self.NLinear = NLinear
        self.Periodic = Periodic
    def factory(*args_, **kwargs_):
        if BoundaryCondition.subclass:
            return BoundaryCondition.subclass(*args_, **kwargs_)
        else:
            return BoundaryCondition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Linear(self): return self.Linear
    def set_Linear(self, Linear): self.Linear = Linear
    def get_NLinear(self): return self.NLinear
    def set_NLinear(self, NLinear): self.NLinear = NLinear
    def get_Periodic(self): return self.Periodic
    def set_Periodic(self, Periodic): self.Periodic = Periodic
    def hasContent_(self):
        if (
            self.Linear is not None or
            self.NLinear is not None or
            self.Periodic is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BoundaryCondition', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BoundaryCondition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BoundaryCondition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BoundaryCondition'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BoundaryCondition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Linear is not None:
            self.Linear.export(outfile, level, namespace_, name_='Linear', pretty_print=pretty_print)
        if self.NLinear is not None:
            self.NLinear.export(outfile, level, namespace_, name_='NLinear', pretty_print=pretty_print)
        if self.Periodic is not None:
            self.Periodic.export(outfile, level, namespace_, name_='Periodic', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='BoundaryCondition'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Linear is not None:
            showIndent(outfile, level)
            outfile.write('Linear=model_.LinearType(\n')
            self.Linear.exportLiteral(outfile, level, name_='Linear')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NLinear is not None:
            showIndent(outfile, level)
            outfile.write('NLinear=model_.NLinearType(\n')
            self.NLinear.exportLiteral(outfile, level, name_='NLinear')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Periodic is not None:
            showIndent(outfile, level)
            outfile.write('Periodic=model_.PeriodicType(\n')
            self.Periodic.exportLiteral(outfile, level, name_='Periodic')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Linear':
            obj_ = LinearType.factory()
            obj_.build(child_)
            self.Linear = obj_
        elif nodeName_ == 'NLinear':
            obj_ = NLinearType.factory()
            obj_.build(child_)
            self.NLinear = obj_
        elif nodeName_ == 'Periodic':
            obj_ = PeriodicType.factory()
            obj_.build(child_)
            self.Periodic = obj_
# end class BoundaryCondition


class NonSmoothSolver(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, iparam=None, dparam=None):
        self.Name = _cast(None, Name)
        self.iparam = iparam
        self.dparam = dparam
    def factory(*args_, **kwargs_):
        if NonSmoothSolver.subclass:
            return NonSmoothSolver.subclass(*args_, **kwargs_)
        else:
            return NonSmoothSolver(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_iparam(self): return self.iparam
    def set_iparam(self, iparam): self.iparam = iparam
    def get_dparam(self): return self.dparam
    def set_dparam(self, dparam): self.dparam = dparam
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def hasContent_(self):
        if (
            self.iparam is not None or
            self.dparam is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NonSmoothSolver', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NonSmoothSolver')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NonSmoothSolver', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NonSmoothSolver'):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            outfile.write(' Name=%s' % (self.gds_format_string(quote_attrib(self.Name).encode(ExternalEncoding), input_name='Name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NonSmoothSolver', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.iparam is not None:
            self.iparam.export(outfile, level, namespace_, name_='iparam', pretty_print=pretty_print)
        if self.dparam is not None:
            self.dparam.export(outfile, level, namespace_, name_='dparam', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NonSmoothSolver'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            showIndent(outfile, level)
            outfile.write('Name="%s",\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.iparam is not None:
            showIndent(outfile, level)
            outfile.write('iparam=model_.vector(\n')
            self.iparam.exportLiteral(outfile, level, name_='iparam')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dparam is not None:
            showIndent(outfile, level)
            outfile.write('dparam=model_.vector(\n')
            self.dparam.exportLiteral(outfile, level, name_='dparam')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Name', node)
        if value is not None and 'Name' not in already_processed:
            already_processed.add('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'iparam':
            obj_ = vector.factory()
            obj_.build(child_)
            self.iparam = obj_
        elif nodeName_ == 'dparam':
            obj_ = vector.factory()
            obj_.build(child_)
            self.dparam = obj_
# end class NonSmoothSolver


class index_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, all='false', indexList=None):
        self.all = _cast(None, all)
        if indexList is None:
            self.indexList = []
        else:
            self.indexList = indexList
    def factory(*args_, **kwargs_):
        if index_list.subclass:
            return index_list.subclass(*args_, **kwargs_)
        else:
            return index_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indexList(self): return self.indexList
    def set_indexList(self, indexList): self.indexList = indexList
    def add_indexList(self, value): self.indexList.append(value)
    def insert_indexList(self, index, value): self.indexList[index] = value
    def get_all(self): return self.all
    def set_all(self, all): self.all = all
    def validate_boolean(self, value):
        # Validate type boolean, a restriction on xsd:boolean.
        pass
    def hasContent_(self):
        if (
            self.indexList
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='index_list', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='index_list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='index_list', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='index_list'):
        if self.all is not None and 'all' not in already_processed:
            already_processed.add('all')
            outfile.write(' all=%s' % (quote_attrib(self.all), ))
    def exportChildren(self, outfile, level, namespace_='', name_='index_list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for indexList_ in self.indexList:
            indexList_.export(outfile, level, namespace_, name_='indexList', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='index_list'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.all is not None and 'all' not in already_processed:
            already_processed.add('all')
            showIndent(outfile, level)
            outfile.write('all=%s,\n' % (self.all,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('indexList=[\n')
        level += 1
        for indexList_ in self.indexList:
            showIndent(outfile, level)
            outfile.write('model_.vector(\n')
            indexList_.exportLiteral(outfile, level, name_='vector')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('all', node)
        if value is not None and 'all' not in already_processed:
            already_processed.add('all')
            if value in ('true', '1'):
                self.all = True
            elif value in ('false', '0'):
                self.all = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_boolean(self.all)    # validate type boolean
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'indexList':
            obj_ = vector.factory()
            obj_.build(child_)
            self.indexList.append(obj_)
# end class index_list


class SiconosModel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Title=None, Author=None, Description=None, Date=None, SchemaXML=None, Time=None, NSDS=None, Simulation=None):
        self.Title = Title
        self.Author = Author
        self.Description = Description
        self.Date = Date
        self.SchemaXML = SchemaXML
        self.Time = Time
        self.NSDS = NSDS
        self.Simulation = Simulation
    def factory(*args_, **kwargs_):
        if SiconosModel.subclass:
            return SiconosModel.subclass(*args_, **kwargs_)
        else:
            return SiconosModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Title(self): return self.Title
    def set_Title(self, Title): self.Title = Title
    def get_Author(self): return self.Author
    def set_Author(self, Author): self.Author = Author
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def get_SchemaXML(self): return self.SchemaXML
    def set_SchemaXML(self, SchemaXML): self.SchemaXML = SchemaXML
    def get_Time(self): return self.Time
    def set_Time(self, Time): self.Time = Time
    def get_NSDS(self): return self.NSDS
    def set_NSDS(self, NSDS): self.NSDS = NSDS
    def get_Simulation(self): return self.Simulation
    def set_Simulation(self, Simulation): self.Simulation = Simulation
    def hasContent_(self):
        if (
            self.Title is not None or
            self.Author is not None or
            self.Description is not None or
            self.Date is not None or
            self.SchemaXML is not None or
            self.Time is not None or
            self.NSDS is not None or
            self.Simulation is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SiconosModel', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SiconosModel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SiconosModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SiconosModel'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SiconosModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTitle>%s</%sTitle>%s' % (namespace_, self.gds_format_string(quote_xml(self.Title).encode(ExternalEncoding), input_name='Title'), namespace_, eol_))
        if self.Author is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAuthor>%s</%sAuthor>%s' % (namespace_, self.gds_format_string(quote_xml(self.Author).encode(ExternalEncoding), input_name='Author'), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
        if self.Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDate>%s</%sDate>%s' % (namespace_, self.gds_format_string(quote_xml(self.Date).encode(ExternalEncoding), input_name='Date'), namespace_, eol_))
        if self.SchemaXML is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSchemaXML>%s</%sSchemaXML>%s' % (namespace_, self.gds_format_string(quote_xml(self.SchemaXML).encode(ExternalEncoding), input_name='SchemaXML'), namespace_, eol_))
        if self.Time is not None:
            self.Time.export(outfile, level, namespace_, name_='Time', pretty_print=pretty_print)
        if self.NSDS is not None:
            self.NSDS.export(outfile, level, namespace_, name_='NSDS', pretty_print=pretty_print)
        if self.Simulation is not None:
            self.Simulation.export(outfile, level, namespace_, name_='Simulation', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SiconosModel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Title is not None:
            showIndent(outfile, level)
            outfile.write('Title=%s,\n' % quote_python(self.Title).encode(ExternalEncoding))
        if self.Author is not None:
            showIndent(outfile, level)
            outfile.write('Author=%s,\n' % quote_python(self.Author).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.Date is not None:
            showIndent(outfile, level)
            outfile.write('Date=%s,\n' % quote_python(self.Date).encode(ExternalEncoding))
        if self.SchemaXML is not None:
            showIndent(outfile, level)
            outfile.write('SchemaXML=%s,\n' % quote_python(self.SchemaXML).encode(ExternalEncoding))
        if self.Time is not None:
            showIndent(outfile, level)
            outfile.write('Time=model_.ModelTime(\n')
            self.Time.exportLiteral(outfile, level, name_='Time')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NSDS is not None:
            showIndent(outfile, level)
            outfile.write('NSDS=model_.NSDSType(\n')
            self.NSDS.exportLiteral(outfile, level, name_='NSDS')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Simulation is not None:
            showIndent(outfile, level)
            outfile.write('Simulation=model_.SimulationType(\n')
            self.Simulation.exportLiteral(outfile, level, name_='Simulation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Title':
            Title_ = child_.text
            Title_ = self.gds_validate_string(Title_, node, 'Title')
            self.Title = Title_
        elif nodeName_ == 'Author':
            Author_ = child_.text
            Author_ = self.gds_validate_string(Author_, node, 'Author')
            self.Author = Author_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Date':
            Date_ = child_.text
            Date_ = self.gds_validate_string(Date_, node, 'Date')
            self.Date = Date_
        elif nodeName_ == 'SchemaXML':
            SchemaXML_ = child_.text
            SchemaXML_ = self.gds_validate_string(SchemaXML_, node, 'SchemaXML')
            self.SchemaXML = SchemaXML_
        elif nodeName_ == 'Time':
            obj_ = ModelTime.factory()
            obj_.build(child_)
            self.Time = obj_
        elif nodeName_ == 'NSDS':
            obj_ = NSDSType.factory()
            obj_.build(child_)
            self.NSDS = obj_
        elif nodeName_ == 'Simulation':
            obj_ = SimulationType.factory()
            obj_.build(child_)
            self.Simulation = obj_
# end class SiconosModel


class LinearType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Omega=None, Omega0=None, OmegaT=None):
        self.Omega = Omega
        self.Omega0 = Omega0
        self.OmegaT = OmegaT
    def factory(*args_, **kwargs_):
        if LinearType.subclass:
            return LinearType.subclass(*args_, **kwargs_)
        else:
            return LinearType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Omega(self): return self.Omega
    def set_Omega(self, Omega): self.Omega = Omega
    def get_Omega0(self): return self.Omega0
    def set_Omega0(self, Omega0): self.Omega0 = Omega0
    def get_OmegaT(self): return self.OmegaT
    def set_OmegaT(self, OmegaT): self.OmegaT = OmegaT
    def hasContent_(self):
        if (
            self.Omega is not None or
            self.Omega0 is not None or
            self.OmegaT is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LinearType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinearType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LinearType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinearType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LinearType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Omega is not None:
            self.Omega.export(outfile, level, namespace_, name_='Omega', pretty_print=pretty_print)
        if self.Omega0 is not None:
            self.Omega0.export(outfile, level, namespace_, name_='Omega0', pretty_print=pretty_print)
        if self.OmegaT is not None:
            self.OmegaT.export(outfile, level, namespace_, name_='OmegaT', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LinearType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Omega is not None:
            showIndent(outfile, level)
            outfile.write('Omega=model_.vector(\n')
            self.Omega.exportLiteral(outfile, level, name_='Omega')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Omega0 is not None:
            showIndent(outfile, level)
            outfile.write('Omega0=model_.matrix(\n')
            self.Omega0.exportLiteral(outfile, level, name_='Omega0')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OmegaT is not None:
            showIndent(outfile, level)
            outfile.write('OmegaT=model_.matrix(\n')
            self.OmegaT.exportLiteral(outfile, level, name_='OmegaT')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Omega':
            obj_ = vector.factory()
            obj_.build(child_)
            self.Omega = obj_
        elif nodeName_ == 'Omega0':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.Omega0 = obj_
        elif nodeName_ == 'OmegaT':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.OmegaT = obj_
# end class LinearType


class NLinearType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, empty1=None):
        self.empty1 = empty1
    def factory(*args_, **kwargs_):
        if NLinearType.subclass:
            return NLinearType.subclass(*args_, **kwargs_)
        else:
            return NLinearType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_empty1(self): return self.empty1
    def set_empty1(self, empty1): self.empty1 = empty1
    def validate_positiveDouble(self, value):
        # Validate type positiveDouble, a restriction on xsd:double.
        pass
    def hasContent_(self):
        if (
            self.empty1 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NLinearType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NLinearType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NLinearType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NLinearType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NLinearType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.empty1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sempty1>%s</%sempty1>%s' % (namespace_, self.gds_format_double(self.empty1, input_name='empty1'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='NLinearType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.empty1 is not None:
            showIndent(outfile, level)
            outfile.write('empty1=%e,\n' % self.empty1)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'empty1':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'empty1')
            self.empty1 = fval_
            self.validate_positiveDouble(self.empty1)    # validate type positiveDouble
# end class NLinearType


class PeriodicType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, empty2=None):
        self.empty2 = empty2
    def factory(*args_, **kwargs_):
        if PeriodicType.subclass:
            return PeriodicType.subclass(*args_, **kwargs_)
        else:
            return PeriodicType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_empty2(self): return self.empty2
    def set_empty2(self, empty2): self.empty2 = empty2
    def validate_positiveDouble(self, value):
        # Validate type positiveDouble, a restriction on xsd:double.
        pass
    def hasContent_(self):
        if (
            self.empty2 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PeriodicType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PeriodicType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PeriodicType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PeriodicType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PeriodicType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.empty2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sempty2>%s</%sempty2>%s' % (namespace_, self.gds_format_double(self.empty2, input_name='empty2'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='PeriodicType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.empty2 is not None:
            showIndent(outfile, level)
            outfile.write('empty2=%e,\n' % self.empty2)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'empty2':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'empty2')
            self.empty2 = fval_
            self.validate_positiveDouble(self.empty2)    # validate type positiveDouble
# end class PeriodicType


class NSDSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, bvp=None, DS_LMGC90=None, DS_Definition=None, Interaction_Definition=None):
        self.bvp = _cast(None, bvp)
        self.DS_LMGC90 = DS_LMGC90
        self.DS_Definition = DS_Definition
        self.Interaction_Definition = Interaction_Definition
    def factory(*args_, **kwargs_):
        if NSDSType.subclass:
            return NSDSType.subclass(*args_, **kwargs_)
        else:
            return NSDSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DS_LMGC90(self): return self.DS_LMGC90
    def set_DS_LMGC90(self, DS_LMGC90): self.DS_LMGC90 = DS_LMGC90
    def get_DS_Definition(self): return self.DS_Definition
    def set_DS_Definition(self, DS_Definition): self.DS_Definition = DS_Definition
    def get_Interaction_Definition(self): return self.Interaction_Definition
    def set_Interaction_Definition(self, Interaction_Definition): self.Interaction_Definition = Interaction_Definition
    def get_bvp(self): return self.bvp
    def set_bvp(self, bvp): self.bvp = bvp
    def validate_boolean(self, value):
        # Validate type boolean, a restriction on xsd:boolean.
        pass
    def hasContent_(self):
        if (
            self.DS_LMGC90 is not None or
            self.DS_Definition is not None or
            self.Interaction_Definition is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NSDSType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NSDSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NSDSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NSDSType'):
        if self.bvp is not None and 'bvp' not in already_processed:
            already_processed.add('bvp')
            outfile.write(' bvp=%s' % (quote_attrib(self.bvp), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NSDSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DS_LMGC90 is not None:
            self.DS_LMGC90.export(outfile, level, namespace_, name_='DS_LMGC90', pretty_print=pretty_print)
        if self.DS_Definition is not None:
            self.DS_Definition.export(outfile, level, namespace_, name_='DS_Definition', pretty_print=pretty_print)
        if self.Interaction_Definition is not None:
            self.Interaction_Definition.export(outfile, level, namespace_, name_='Interaction_Definition', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NSDSType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.bvp is not None and 'bvp' not in already_processed:
            already_processed.add('bvp')
            showIndent(outfile, level)
            outfile.write('bvp=%s,\n' % (self.bvp,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DS_LMGC90 is not None:
            showIndent(outfile, level)
            outfile.write('DS_LMGC90=model_.DS_LMGC90Type(\n')
            self.DS_LMGC90.exportLiteral(outfile, level, name_='DS_LMGC90')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DS_Definition is not None:
            showIndent(outfile, level)
            outfile.write('DS_Definition=model_.DS_DefinitionType(\n')
            self.DS_Definition.exportLiteral(outfile, level, name_='DS_Definition')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Interaction_Definition is not None:
            showIndent(outfile, level)
            outfile.write('Interaction_Definition=model_.Interaction_DefinitionType(\n')
            self.Interaction_Definition.exportLiteral(outfile, level, name_='Interaction_Definition')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('bvp', node)
        if value is not None and 'bvp' not in already_processed:
            already_processed.add('bvp')
            if value in ('true', '1'):
                self.bvp = True
            elif value in ('false', '0'):
                self.bvp = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_boolean(self.bvp)    # validate type boolean
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DS_LMGC90':
            obj_ = DS_LMGC90Type.factory()
            obj_.build(child_)
            self.DS_LMGC90 = obj_
        elif nodeName_ == 'DS_Definition':
            obj_ = DS_DefinitionType.factory()
            obj_.build(child_)
            self.DS_Definition = obj_
        elif nodeName_ == 'Interaction_Definition':
            obj_ = Interaction_DefinitionType.factory()
            obj_.build(child_)
            self.Interaction_Definition = obj_
# end class NSDSType


class DS_LMGC90Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, empty=None):
        self.empty = empty
    def factory(*args_, **kwargs_):
        if DS_LMGC90Type.subclass:
            return DS_LMGC90Type.subclass(*args_, **kwargs_)
        else:
            return DS_LMGC90Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_empty(self): return self.empty
    def set_empty(self, empty): self.empty = empty
    def hasContent_(self):
        if (
            self.empty is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DS_LMGC90Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DS_LMGC90Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DS_LMGC90Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DS_LMGC90Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DS_LMGC90Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.empty is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sempty>%s</%sempty>%s' % (namespace_, self.gds_format_string(quote_xml(self.empty).encode(ExternalEncoding), input_name='empty'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='DS_LMGC90Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.empty is not None:
            showIndent(outfile, level)
            outfile.write('empty=%s,\n' % quote_python(self.empty).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'empty':
            empty_ = child_.text
            empty_ = self.gds_validate_string(empty_, node, 'empty')
            self.empty = empty_
# end class DS_LMGC90Type


class DS_DefinitionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FirstOrderNonLinearDS=None, FirstOrderLinearDS=None, FirstOrderLinearTIDS=None, LagrangianDS=None, LagrangianLinearTIDS=None):
        if FirstOrderNonLinearDS is None:
            self.FirstOrderNonLinearDS = []
        else:
            self.FirstOrderNonLinearDS = FirstOrderNonLinearDS
        if FirstOrderLinearDS is None:
            self.FirstOrderLinearDS = []
        else:
            self.FirstOrderLinearDS = FirstOrderLinearDS
        if FirstOrderLinearTIDS is None:
            self.FirstOrderLinearTIDS = []
        else:
            self.FirstOrderLinearTIDS = FirstOrderLinearTIDS
        if LagrangianDS is None:
            self.LagrangianDS = []
        else:
            self.LagrangianDS = LagrangianDS
        if LagrangianLinearTIDS is None:
            self.LagrangianLinearTIDS = []
        else:
            self.LagrangianLinearTIDS = LagrangianLinearTIDS
    def factory(*args_, **kwargs_):
        if DS_DefinitionType.subclass:
            return DS_DefinitionType.subclass(*args_, **kwargs_)
        else:
            return DS_DefinitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FirstOrderNonLinearDS(self): return self.FirstOrderNonLinearDS
    def set_FirstOrderNonLinearDS(self, FirstOrderNonLinearDS): self.FirstOrderNonLinearDS = FirstOrderNonLinearDS
    def add_FirstOrderNonLinearDS(self, value): self.FirstOrderNonLinearDS.append(value)
    def insert_FirstOrderNonLinearDS(self, index, value): self.FirstOrderNonLinearDS[index] = value
    def get_FirstOrderLinearDS(self): return self.FirstOrderLinearDS
    def set_FirstOrderLinearDS(self, FirstOrderLinearDS): self.FirstOrderLinearDS = FirstOrderLinearDS
    def add_FirstOrderLinearDS(self, value): self.FirstOrderLinearDS.append(value)
    def insert_FirstOrderLinearDS(self, index, value): self.FirstOrderLinearDS[index] = value
    def get_FirstOrderLinearTIDS(self): return self.FirstOrderLinearTIDS
    def set_FirstOrderLinearTIDS(self, FirstOrderLinearTIDS): self.FirstOrderLinearTIDS = FirstOrderLinearTIDS
    def add_FirstOrderLinearTIDS(self, value): self.FirstOrderLinearTIDS.append(value)
    def insert_FirstOrderLinearTIDS(self, index, value): self.FirstOrderLinearTIDS[index] = value
    def get_LagrangianDS(self): return self.LagrangianDS
    def set_LagrangianDS(self, LagrangianDS): self.LagrangianDS = LagrangianDS
    def add_LagrangianDS(self, value): self.LagrangianDS.append(value)
    def insert_LagrangianDS(self, index, value): self.LagrangianDS[index] = value
    def get_LagrangianLinearTIDS(self): return self.LagrangianLinearTIDS
    def set_LagrangianLinearTIDS(self, LagrangianLinearTIDS): self.LagrangianLinearTIDS = LagrangianLinearTIDS
    def add_LagrangianLinearTIDS(self, value): self.LagrangianLinearTIDS.append(value)
    def insert_LagrangianLinearTIDS(self, index, value): self.LagrangianLinearTIDS[index] = value
    def hasContent_(self):
        if (
            self.FirstOrderNonLinearDS or
            self.FirstOrderLinearDS or
            self.FirstOrderLinearTIDS or
            self.LagrangianDS or
            self.LagrangianLinearTIDS
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DS_DefinitionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DS_DefinitionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DS_DefinitionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DS_DefinitionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DS_DefinitionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FirstOrderNonLinearDS_ in self.FirstOrderNonLinearDS:
            FirstOrderNonLinearDS_.export(outfile, level, namespace_, name_='FirstOrderNonLinearDS', pretty_print=pretty_print)
        for FirstOrderLinearDS_ in self.FirstOrderLinearDS:
            FirstOrderLinearDS_.export(outfile, level, namespace_, name_='FirstOrderLinearDS', pretty_print=pretty_print)
        for FirstOrderLinearTIDS_ in self.FirstOrderLinearTIDS:
            FirstOrderLinearTIDS_.export(outfile, level, namespace_, name_='FirstOrderLinearTIDS', pretty_print=pretty_print)
        for LagrangianDS_ in self.LagrangianDS:
            LagrangianDS_.export(outfile, level, namespace_, name_='LagrangianDS', pretty_print=pretty_print)
        for LagrangianLinearTIDS_ in self.LagrangianLinearTIDS:
            LagrangianLinearTIDS_.export(outfile, level, namespace_, name_='LagrangianLinearTIDS', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DS_DefinitionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('FirstOrderNonLinearDS=[\n')
        level += 1
        for FirstOrderNonLinearDS_ in self.FirstOrderNonLinearDS:
            showIndent(outfile, level)
            outfile.write('model_.FirstOrderNonLinearDSType(\n')
            FirstOrderNonLinearDS_.exportLiteral(outfile, level, name_='FirstOrderNonLinearDSType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FirstOrderLinearDS=[\n')
        level += 1
        for FirstOrderLinearDS_ in self.FirstOrderLinearDS:
            showIndent(outfile, level)
            outfile.write('model_.FirstOrderLinearDSType(\n')
            FirstOrderLinearDS_.exportLiteral(outfile, level, name_='FirstOrderLinearDSType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FirstOrderLinearTIDS=[\n')
        level += 1
        for FirstOrderLinearTIDS_ in self.FirstOrderLinearTIDS:
            showIndent(outfile, level)
            outfile.write('model_.FirstOrderLinearTIDSType(\n')
            FirstOrderLinearTIDS_.exportLiteral(outfile, level, name_='FirstOrderLinearTIDSType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LagrangianDS=[\n')
        level += 1
        for LagrangianDS_ in self.LagrangianDS:
            showIndent(outfile, level)
            outfile.write('model_.LagrangianDSType(\n')
            LagrangianDS_.exportLiteral(outfile, level, name_='LagrangianDSType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LagrangianLinearTIDS=[\n')
        level += 1
        for LagrangianLinearTIDS_ in self.LagrangianLinearTIDS:
            showIndent(outfile, level)
            outfile.write('model_.LagrangianLinearTIDSType(\n')
            LagrangianLinearTIDS_.exportLiteral(outfile, level, name_='LagrangianLinearTIDSType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FirstOrderNonLinearDS':
            obj_ = FirstOrderNonLinearDSType.factory()
            obj_.build(child_)
            self.FirstOrderNonLinearDS.append(obj_)
        elif nodeName_ == 'FirstOrderLinearDS':
            obj_ = FirstOrderLinearDSType.factory()
            obj_.build(child_)
            self.FirstOrderLinearDS.append(obj_)
        elif nodeName_ == 'FirstOrderLinearTIDS':
            obj_ = FirstOrderLinearTIDSType.factory()
            obj_.build(child_)
            self.FirstOrderLinearTIDS.append(obj_)
        elif nodeName_ == 'LagrangianDS':
            obj_ = LagrangianDSType.factory()
            obj_.build(child_)
            self.LagrangianDS.append(obj_)
        elif nodeName_ == 'LagrangianLinearTIDS':
            obj_ = LagrangianLinearTIDSType.factory()
            obj_.build(child_)
            self.LagrangianLinearTIDS.append(obj_)
# end class DS_DefinitionType


class FirstOrderNonLinearDSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, number=None, x0=None, x=None, M=None, StepsInMemory=None, xMemory=None, f=None, Jacobianfx=None):
        self.number = _cast(int, number)
        self.x0 = x0
        self.x = x
        self.M = M
        self.StepsInMemory = StepsInMemory
        self.xMemory = xMemory
        self.f = f
        self.Jacobianfx = Jacobianfx
    def factory(*args_, **kwargs_):
        if FirstOrderNonLinearDSType.subclass:
            return FirstOrderNonLinearDSType.subclass(*args_, **kwargs_)
        else:
            return FirstOrderNonLinearDSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_x0(self): return self.x0
    def set_x0(self, x0): self.x0 = x0
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def get_M(self): return self.M
    def set_M(self, M): self.M = M
    def get_StepsInMemory(self): return self.StepsInMemory
    def set_StepsInMemory(self, StepsInMemory): self.StepsInMemory = StepsInMemory
    def get_xMemory(self): return self.xMemory
    def set_xMemory(self, xMemory): self.xMemory = xMemory
    def get_f(self): return self.f
    def set_f(self, f): self.f = f
    def get_Jacobianfx(self): return self.Jacobianfx
    def set_Jacobianfx(self, Jacobianfx): self.Jacobianfx = Jacobianfx
    def get_number(self): return self.number
    def set_number(self, number): self.number = number
    def hasContent_(self):
        if (
            self.x0 is not None or
            self.x is not None or
            self.M is not None or
            self.StepsInMemory is not None or
            self.xMemory is not None or
            self.f is not None or
            self.Jacobianfx is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FirstOrderNonLinearDSType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FirstOrderNonLinearDSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FirstOrderNonLinearDSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FirstOrderNonLinearDSType'):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
    def exportChildren(self, outfile, level, namespace_='', name_='FirstOrderNonLinearDSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.x0 is not None:
            self.x0.export(outfile, level, namespace_, name_='x0', pretty_print=pretty_print)
        if self.x is not None:
            self.x.export(outfile, level, namespace_, name_='x', pretty_print=pretty_print)
        if self.M is not None:
            self.M.export(outfile, level, namespace_, name_='M', pretty_print=pretty_print)
        if self.StepsInMemory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStepsInMemory>%s</%sStepsInMemory>%s' % (namespace_, self.gds_format_integer(self.StepsInMemory, input_name='StepsInMemory'), namespace_, eol_))
        if self.xMemory is not None:
            self.xMemory.export(outfile, level, namespace_, name_='xMemory', pretty_print=pretty_print)
        if self.f is not None:
            self.f.export(outfile, level, namespace_, name_='f', pretty_print=pretty_print)
        if self.Jacobianfx is not None:
            self.Jacobianfx.export(outfile, level, namespace_, name_='Jacobianfx', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FirstOrderNonLinearDSType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            showIndent(outfile, level)
            outfile.write('number=%d,\n' % (self.number,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.x0 is not None:
            showIndent(outfile, level)
            outfile.write('x0=model_.vector(\n')
            self.x0.exportLiteral(outfile, level, name_='x0')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.x is not None:
            showIndent(outfile, level)
            outfile.write('x=model_.vector(\n')
            self.x.exportLiteral(outfile, level, name_='x')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.M is not None:
            showIndent(outfile, level)
            outfile.write('M=model_.matrix(\n')
            self.M.exportLiteral(outfile, level, name_='M')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StepsInMemory is not None:
            showIndent(outfile, level)
            outfile.write('StepsInMemory=%d,\n' % self.StepsInMemory)
        if self.xMemory is not None:
            showIndent(outfile, level)
            outfile.write('xMemory=model_.memory(\n')
            self.xMemory.exportLiteral(outfile, level, name_='xMemory')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.f is not None:
            showIndent(outfile, level)
            outfile.write('f=model_.vector(\n')
            self.f.exportLiteral(outfile, level, name_='f')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Jacobianfx is not None:
            showIndent(outfile, level)
            outfile.write('Jacobianfx=model_.matrix(\n')
            self.Jacobianfx.exportLiteral(outfile, level, name_='Jacobianfx')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            try:
                self.number = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'x0':
            obj_ = vector.factory()
            obj_.build(child_)
            self.x0 = obj_
        elif nodeName_ == 'x':
            obj_ = vector.factory()
            obj_.build(child_)
            self.x = obj_
        elif nodeName_ == 'M':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.M = obj_
        elif nodeName_ == 'StepsInMemory':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'StepsInMemory')
            self.StepsInMemory = ival_
        elif nodeName_ == 'xMemory':
            obj_ = memory.factory()
            obj_.build(child_)
            self.xMemory = obj_
        elif nodeName_ == 'f':
            obj_ = vector.factory()
            obj_.build(child_)
            self.f = obj_
        elif nodeName_ == 'Jacobianfx':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.Jacobianfx = obj_
# end class FirstOrderNonLinearDSType


class FirstOrderLinearDSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, number=None, x0=None, x=None, M=None, StepsInMemory=None, xMemory=None, A=None, b=None):
        self.number = _cast(int, number)
        self.x0 = x0
        self.x = x
        self.M = M
        self.StepsInMemory = StepsInMemory
        self.xMemory = xMemory
        self.A = A
        self.b = b
    def factory(*args_, **kwargs_):
        if FirstOrderLinearDSType.subclass:
            return FirstOrderLinearDSType.subclass(*args_, **kwargs_)
        else:
            return FirstOrderLinearDSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_x0(self): return self.x0
    def set_x0(self, x0): self.x0 = x0
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def get_M(self): return self.M
    def set_M(self, M): self.M = M
    def get_StepsInMemory(self): return self.StepsInMemory
    def set_StepsInMemory(self, StepsInMemory): self.StepsInMemory = StepsInMemory
    def get_xMemory(self): return self.xMemory
    def set_xMemory(self, xMemory): self.xMemory = xMemory
    def get_A(self): return self.A
    def set_A(self, A): self.A = A
    def get_b(self): return self.b
    def set_b(self, b): self.b = b
    def get_number(self): return self.number
    def set_number(self, number): self.number = number
    def hasContent_(self):
        if (
            self.x0 is not None or
            self.x is not None or
            self.M is not None or
            self.StepsInMemory is not None or
            self.xMemory is not None or
            self.A is not None or
            self.b is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FirstOrderLinearDSType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FirstOrderLinearDSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FirstOrderLinearDSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FirstOrderLinearDSType'):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
    def exportChildren(self, outfile, level, namespace_='', name_='FirstOrderLinearDSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.x0 is not None:
            self.x0.export(outfile, level, namespace_, name_='x0', pretty_print=pretty_print)
        if self.x is not None:
            self.x.export(outfile, level, namespace_, name_='x', pretty_print=pretty_print)
        if self.M is not None:
            self.M.export(outfile, level, namespace_, name_='M', pretty_print=pretty_print)
        if self.StepsInMemory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStepsInMemory>%s</%sStepsInMemory>%s' % (namespace_, self.gds_format_integer(self.StepsInMemory, input_name='StepsInMemory'), namespace_, eol_))
        if self.xMemory is not None:
            self.xMemory.export(outfile, level, namespace_, name_='xMemory', pretty_print=pretty_print)
        if self.A is not None:
            self.A.export(outfile, level, namespace_, name_='A', pretty_print=pretty_print)
        if self.b is not None:
            self.b.export(outfile, level, namespace_, name_='b', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FirstOrderLinearDSType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            showIndent(outfile, level)
            outfile.write('number=%d,\n' % (self.number,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.x0 is not None:
            showIndent(outfile, level)
            outfile.write('x0=model_.vector(\n')
            self.x0.exportLiteral(outfile, level, name_='x0')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.x is not None:
            showIndent(outfile, level)
            outfile.write('x=model_.vector(\n')
            self.x.exportLiteral(outfile, level, name_='x')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.M is not None:
            showIndent(outfile, level)
            outfile.write('M=model_.matrix(\n')
            self.M.exportLiteral(outfile, level, name_='M')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StepsInMemory is not None:
            showIndent(outfile, level)
            outfile.write('StepsInMemory=%d,\n' % self.StepsInMemory)
        if self.xMemory is not None:
            showIndent(outfile, level)
            outfile.write('xMemory=model_.memory(\n')
            self.xMemory.exportLiteral(outfile, level, name_='xMemory')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.A is not None:
            showIndent(outfile, level)
            outfile.write('A=model_.matrix(\n')
            self.A.exportLiteral(outfile, level, name_='A')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.b is not None:
            showIndent(outfile, level)
            outfile.write('b=model_.vector(\n')
            self.b.exportLiteral(outfile, level, name_='b')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            try:
                self.number = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'x0':
            obj_ = vector.factory()
            obj_.build(child_)
            self.x0 = obj_
        elif nodeName_ == 'x':
            obj_ = vector.factory()
            obj_.build(child_)
            self.x = obj_
        elif nodeName_ == 'M':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.M = obj_
        elif nodeName_ == 'StepsInMemory':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'StepsInMemory')
            self.StepsInMemory = ival_
        elif nodeName_ == 'xMemory':
            obj_ = memory.factory()
            obj_.build(child_)
            self.xMemory = obj_
        elif nodeName_ == 'A':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.A = obj_
        elif nodeName_ == 'b':
            obj_ = vector.factory()
            obj_.build(child_)
            self.b = obj_
# end class FirstOrderLinearDSType


class FirstOrderLinearTIDSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, number=None, x0=None, x=None, M=None, StepsInMemory=None, xMemory=None, A=None, b=None):
        self.number = _cast(int, number)
        self.x0 = x0
        self.x = x
        self.M = M
        self.StepsInMemory = StepsInMemory
        self.xMemory = xMemory
        self.A = A
        self.b = b
    def factory(*args_, **kwargs_):
        if FirstOrderLinearTIDSType.subclass:
            return FirstOrderLinearTIDSType.subclass(*args_, **kwargs_)
        else:
            return FirstOrderLinearTIDSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_x0(self): return self.x0
    def set_x0(self, x0): self.x0 = x0
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def get_M(self): return self.M
    def set_M(self, M): self.M = M
    def get_StepsInMemory(self): return self.StepsInMemory
    def set_StepsInMemory(self, StepsInMemory): self.StepsInMemory = StepsInMemory
    def get_xMemory(self): return self.xMemory
    def set_xMemory(self, xMemory): self.xMemory = xMemory
    def get_A(self): return self.A
    def set_A(self, A): self.A = A
    def get_b(self): return self.b
    def set_b(self, b): self.b = b
    def get_number(self): return self.number
    def set_number(self, number): self.number = number
    def hasContent_(self):
        if (
            self.x0 is not None or
            self.x is not None or
            self.M is not None or
            self.StepsInMemory is not None or
            self.xMemory is not None or
            self.A is not None or
            self.b is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FirstOrderLinearTIDSType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FirstOrderLinearTIDSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FirstOrderLinearTIDSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FirstOrderLinearTIDSType'):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
    def exportChildren(self, outfile, level, namespace_='', name_='FirstOrderLinearTIDSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.x0 is not None:
            self.x0.export(outfile, level, namespace_, name_='x0', pretty_print=pretty_print)
        if self.x is not None:
            self.x.export(outfile, level, namespace_, name_='x', pretty_print=pretty_print)
        if self.M is not None:
            self.M.export(outfile, level, namespace_, name_='M', pretty_print=pretty_print)
        if self.StepsInMemory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStepsInMemory>%s</%sStepsInMemory>%s' % (namespace_, self.gds_format_integer(self.StepsInMemory, input_name='StepsInMemory'), namespace_, eol_))
        if self.xMemory is not None:
            self.xMemory.export(outfile, level, namespace_, name_='xMemory', pretty_print=pretty_print)
        if self.A is not None:
            self.A.export(outfile, level, namespace_, name_='A', pretty_print=pretty_print)
        if self.b is not None:
            self.b.export(outfile, level, namespace_, name_='b', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FirstOrderLinearTIDSType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            showIndent(outfile, level)
            outfile.write('number=%d,\n' % (self.number,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.x0 is not None:
            showIndent(outfile, level)
            outfile.write('x0=model_.vector(\n')
            self.x0.exportLiteral(outfile, level, name_='x0')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.x is not None:
            showIndent(outfile, level)
            outfile.write('x=model_.vector(\n')
            self.x.exportLiteral(outfile, level, name_='x')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.M is not None:
            showIndent(outfile, level)
            outfile.write('M=model_.matrix(\n')
            self.M.exportLiteral(outfile, level, name_='M')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StepsInMemory is not None:
            showIndent(outfile, level)
            outfile.write('StepsInMemory=%d,\n' % self.StepsInMemory)
        if self.xMemory is not None:
            showIndent(outfile, level)
            outfile.write('xMemory=model_.memory(\n')
            self.xMemory.exportLiteral(outfile, level, name_='xMemory')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.A is not None:
            showIndent(outfile, level)
            outfile.write('A=model_.matrix(\n')
            self.A.exportLiteral(outfile, level, name_='A')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.b is not None:
            showIndent(outfile, level)
            outfile.write('b=model_.vector(\n')
            self.b.exportLiteral(outfile, level, name_='b')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            try:
                self.number = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'x0':
            obj_ = vector.factory()
            obj_.build(child_)
            self.x0 = obj_
        elif nodeName_ == 'x':
            obj_ = vector.factory()
            obj_.build(child_)
            self.x = obj_
        elif nodeName_ == 'M':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.M = obj_
        elif nodeName_ == 'StepsInMemory':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'StepsInMemory')
            self.StepsInMemory = ival_
        elif nodeName_ == 'xMemory':
            obj_ = memory.factory()
            obj_.build(child_)
            self.xMemory = obj_
        elif nodeName_ == 'A':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.A = obj_
        elif nodeName_ == 'b':
            obj_ = vector.factory()
            obj_.build(child_)
            self.b = obj_
# end class FirstOrderLinearTIDSType


class LagrangianDSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, number=None, StepsInMemory=None, q=None, q0=None, qMemory=None, Velocity=None, Velocity0=None, VelocityMemory=None, Mass=None, FInt=None, FExt=None, NNL=None, JacobianQFInt=None, JacobianVelocityFInt=None, JacobianQNNL=None, JacobianVelocityNNL=None):
        self.number = _cast(int, number)
        self.StepsInMemory = StepsInMemory
        self.q = q
        self.q0 = q0
        self.qMemory = qMemory
        self.Velocity = Velocity
        self.Velocity0 = Velocity0
        self.VelocityMemory = VelocityMemory
        self.Mass = Mass
        self.FInt = FInt
        self.FExt = FExt
        self.NNL = NNL
        self.JacobianQFInt = JacobianQFInt
        self.JacobianVelocityFInt = JacobianVelocityFInt
        self.JacobianQNNL = JacobianQNNL
        self.JacobianVelocityNNL = JacobianVelocityNNL
    def factory(*args_, **kwargs_):
        if LagrangianDSType.subclass:
            return LagrangianDSType.subclass(*args_, **kwargs_)
        else:
            return LagrangianDSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StepsInMemory(self): return self.StepsInMemory
    def set_StepsInMemory(self, StepsInMemory): self.StepsInMemory = StepsInMemory
    def get_q(self): return self.q
    def set_q(self, q): self.q = q
    def get_q0(self): return self.q0
    def set_q0(self, q0): self.q0 = q0
    def get_qMemory(self): return self.qMemory
    def set_qMemory(self, qMemory): self.qMemory = qMemory
    def get_Velocity(self): return self.Velocity
    def set_Velocity(self, Velocity): self.Velocity = Velocity
    def get_Velocity0(self): return self.Velocity0
    def set_Velocity0(self, Velocity0): self.Velocity0 = Velocity0
    def get_VelocityMemory(self): return self.VelocityMemory
    def set_VelocityMemory(self, VelocityMemory): self.VelocityMemory = VelocityMemory
    def get_Mass(self): return self.Mass
    def set_Mass(self, Mass): self.Mass = Mass
    def get_FInt(self): return self.FInt
    def set_FInt(self, FInt): self.FInt = FInt
    def get_FExt(self): return self.FExt
    def set_FExt(self, FExt): self.FExt = FExt
    def get_NNL(self): return self.NNL
    def set_NNL(self, NNL): self.NNL = NNL
    def get_JacobianQFInt(self): return self.JacobianQFInt
    def set_JacobianQFInt(self, JacobianQFInt): self.JacobianQFInt = JacobianQFInt
    def get_JacobianVelocityFInt(self): return self.JacobianVelocityFInt
    def set_JacobianVelocityFInt(self, JacobianVelocityFInt): self.JacobianVelocityFInt = JacobianVelocityFInt
    def get_JacobianQNNL(self): return self.JacobianQNNL
    def set_JacobianQNNL(self, JacobianQNNL): self.JacobianQNNL = JacobianQNNL
    def get_JacobianVelocityNNL(self): return self.JacobianVelocityNNL
    def set_JacobianVelocityNNL(self, JacobianVelocityNNL): self.JacobianVelocityNNL = JacobianVelocityNNL
    def get_number(self): return self.number
    def set_number(self, number): self.number = number
    def hasContent_(self):
        if (
            self.StepsInMemory is not None or
            self.q is not None or
            self.q0 is not None or
            self.qMemory is not None or
            self.Velocity is not None or
            self.Velocity0 is not None or
            self.VelocityMemory is not None or
            self.Mass is not None or
            self.FInt is not None or
            self.FExt is not None or
            self.NNL is not None or
            self.JacobianQFInt is not None or
            self.JacobianVelocityFInt is not None or
            self.JacobianQNNL is not None or
            self.JacobianVelocityNNL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LagrangianDSType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LagrangianDSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LagrangianDSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LagrangianDSType'):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
    def exportChildren(self, outfile, level, namespace_='', name_='LagrangianDSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StepsInMemory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStepsInMemory>%s</%sStepsInMemory>%s' % (namespace_, self.gds_format_integer(self.StepsInMemory, input_name='StepsInMemory'), namespace_, eol_))
        if self.q is not None:
            self.q.export(outfile, level, namespace_, name_='q', pretty_print=pretty_print)
        if self.q0 is not None:
            self.q0.export(outfile, level, namespace_, name_='q0', pretty_print=pretty_print)
        if self.qMemory is not None:
            self.qMemory.export(outfile, level, namespace_, name_='qMemory', pretty_print=pretty_print)
        if self.Velocity is not None:
            self.Velocity.export(outfile, level, namespace_, name_='Velocity', pretty_print=pretty_print)
        if self.Velocity0 is not None:
            self.Velocity0.export(outfile, level, namespace_, name_='Velocity0', pretty_print=pretty_print)
        if self.VelocityMemory is not None:
            self.VelocityMemory.export(outfile, level, namespace_, name_='VelocityMemory', pretty_print=pretty_print)
        if self.Mass is not None:
            self.Mass.export(outfile, level, namespace_, name_='Mass', pretty_print=pretty_print)
        if self.FInt is not None:
            self.FInt.export(outfile, level, namespace_, name_='FInt', pretty_print=pretty_print)
        if self.FExt is not None:
            self.FExt.export(outfile, level, namespace_, name_='FExt', pretty_print=pretty_print)
        if self.NNL is not None:
            self.NNL.export(outfile, level, namespace_, name_='NNL', pretty_print=pretty_print)
        if self.JacobianQFInt is not None:
            self.JacobianQFInt.export(outfile, level, namespace_, name_='JacobianQFInt', pretty_print=pretty_print)
        if self.JacobianVelocityFInt is not None:
            self.JacobianVelocityFInt.export(outfile, level, namespace_, name_='JacobianVelocityFInt', pretty_print=pretty_print)
        if self.JacobianQNNL is not None:
            self.JacobianQNNL.export(outfile, level, namespace_, name_='JacobianQNNL', pretty_print=pretty_print)
        if self.JacobianVelocityNNL is not None:
            self.JacobianVelocityNNL.export(outfile, level, namespace_, name_='JacobianVelocityNNL', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LagrangianDSType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            showIndent(outfile, level)
            outfile.write('number=%d,\n' % (self.number,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StepsInMemory is not None:
            showIndent(outfile, level)
            outfile.write('StepsInMemory=%d,\n' % self.StepsInMemory)
        if self.q is not None:
            showIndent(outfile, level)
            outfile.write('q=model_.vector(\n')
            self.q.exportLiteral(outfile, level, name_='q')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.q0 is not None:
            showIndent(outfile, level)
            outfile.write('q0=model_.vector(\n')
            self.q0.exportLiteral(outfile, level, name_='q0')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.qMemory is not None:
            showIndent(outfile, level)
            outfile.write('qMemory=model_.memory(\n')
            self.qMemory.exportLiteral(outfile, level, name_='qMemory')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Velocity is not None:
            showIndent(outfile, level)
            outfile.write('Velocity=model_.vector(\n')
            self.Velocity.exportLiteral(outfile, level, name_='Velocity')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Velocity0 is not None:
            showIndent(outfile, level)
            outfile.write('Velocity0=model_.vector(\n')
            self.Velocity0.exportLiteral(outfile, level, name_='Velocity0')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VelocityMemory is not None:
            showIndent(outfile, level)
            outfile.write('VelocityMemory=model_.memory(\n')
            self.VelocityMemory.exportLiteral(outfile, level, name_='VelocityMemory')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Mass is not None:
            showIndent(outfile, level)
            outfile.write('Mass=model_.matrix(\n')
            self.Mass.exportLiteral(outfile, level, name_='Mass')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FInt is not None:
            showIndent(outfile, level)
            outfile.write('FInt=model_.vector(\n')
            self.FInt.exportLiteral(outfile, level, name_='FInt')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FExt is not None:
            showIndent(outfile, level)
            outfile.write('FExt=model_.vector(\n')
            self.FExt.exportLiteral(outfile, level, name_='FExt')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NNL is not None:
            showIndent(outfile, level)
            outfile.write('NNL=model_.vector(\n')
            self.NNL.exportLiteral(outfile, level, name_='NNL')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.JacobianQFInt is not None:
            showIndent(outfile, level)
            outfile.write('JacobianQFInt=model_.matrix(\n')
            self.JacobianQFInt.exportLiteral(outfile, level, name_='JacobianQFInt')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.JacobianVelocityFInt is not None:
            showIndent(outfile, level)
            outfile.write('JacobianVelocityFInt=model_.matrix(\n')
            self.JacobianVelocityFInt.exportLiteral(outfile, level, name_='JacobianVelocityFInt')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.JacobianQNNL is not None:
            showIndent(outfile, level)
            outfile.write('JacobianQNNL=model_.matrix(\n')
            self.JacobianQNNL.exportLiteral(outfile, level, name_='JacobianQNNL')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.JacobianVelocityNNL is not None:
            showIndent(outfile, level)
            outfile.write('JacobianVelocityNNL=model_.matrix(\n')
            self.JacobianVelocityNNL.exportLiteral(outfile, level, name_='JacobianVelocityNNL')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            try:
                self.number = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StepsInMemory':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'StepsInMemory')
            self.StepsInMemory = ival_
        elif nodeName_ == 'q':
            obj_ = vector.factory()
            obj_.build(child_)
            self.q = obj_
        elif nodeName_ == 'q0':
            obj_ = vector.factory()
            obj_.build(child_)
            self.q0 = obj_
        elif nodeName_ == 'qMemory':
            obj_ = memory.factory()
            obj_.build(child_)
            self.qMemory = obj_
        elif nodeName_ == 'Velocity':
            obj_ = vector.factory()
            obj_.build(child_)
            self.Velocity = obj_
        elif nodeName_ == 'Velocity0':
            obj_ = vector.factory()
            obj_.build(child_)
            self.Velocity0 = obj_
        elif nodeName_ == 'VelocityMemory':
            obj_ = memory.factory()
            obj_.build(child_)
            self.VelocityMemory = obj_
        elif nodeName_ == 'Mass':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.Mass = obj_
        elif nodeName_ == 'FInt':
            obj_ = vector.factory()
            obj_.build(child_)
            self.FInt = obj_
        elif nodeName_ == 'FExt':
            obj_ = vector.factory()
            obj_.build(child_)
            self.FExt = obj_
        elif nodeName_ == 'NNL':
            obj_ = vector.factory()
            obj_.build(child_)
            self.NNL = obj_
        elif nodeName_ == 'JacobianQFInt':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.JacobianQFInt = obj_
        elif nodeName_ == 'JacobianVelocityFInt':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.JacobianVelocityFInt = obj_
        elif nodeName_ == 'JacobianQNNL':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.JacobianQNNL = obj_
        elif nodeName_ == 'JacobianVelocityNNL':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.JacobianVelocityNNL = obj_
# end class LagrangianDSType


class LagrangianLinearTIDSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, number=None, StepsInMemory=None, q=None, q0=None, qMemory=None, Velocity=None, Velocity0=None, VelocityMemory=None, FExt=None, Mass=None, K=None, C=None):
        self.number = _cast(int, number)
        self.StepsInMemory = StepsInMemory
        self.q = q
        self.q0 = q0
        self.qMemory = qMemory
        self.Velocity = Velocity
        self.Velocity0 = Velocity0
        self.VelocityMemory = VelocityMemory
        self.FExt = FExt
        self.Mass = Mass
        self.K = K
        self.C = C
    def factory(*args_, **kwargs_):
        if LagrangianLinearTIDSType.subclass:
            return LagrangianLinearTIDSType.subclass(*args_, **kwargs_)
        else:
            return LagrangianLinearTIDSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StepsInMemory(self): return self.StepsInMemory
    def set_StepsInMemory(self, StepsInMemory): self.StepsInMemory = StepsInMemory
    def get_q(self): return self.q
    def set_q(self, q): self.q = q
    def get_q0(self): return self.q0
    def set_q0(self, q0): self.q0 = q0
    def get_qMemory(self): return self.qMemory
    def set_qMemory(self, qMemory): self.qMemory = qMemory
    def get_Velocity(self): return self.Velocity
    def set_Velocity(self, Velocity): self.Velocity = Velocity
    def get_Velocity0(self): return self.Velocity0
    def set_Velocity0(self, Velocity0): self.Velocity0 = Velocity0
    def get_VelocityMemory(self): return self.VelocityMemory
    def set_VelocityMemory(self, VelocityMemory): self.VelocityMemory = VelocityMemory
    def get_FExt(self): return self.FExt
    def set_FExt(self, FExt): self.FExt = FExt
    def get_Mass(self): return self.Mass
    def set_Mass(self, Mass): self.Mass = Mass
    def get_K(self): return self.K
    def set_K(self, K): self.K = K
    def get_C(self): return self.C
    def set_C(self, C): self.C = C
    def get_number(self): return self.number
    def set_number(self, number): self.number = number
    def hasContent_(self):
        if (
            self.StepsInMemory is not None or
            self.q is not None or
            self.q0 is not None or
            self.qMemory is not None or
            self.Velocity is not None or
            self.Velocity0 is not None or
            self.VelocityMemory is not None or
            self.FExt is not None or
            self.Mass is not None or
            self.K is not None or
            self.C is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LagrangianLinearTIDSType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LagrangianLinearTIDSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LagrangianLinearTIDSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LagrangianLinearTIDSType'):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
    def exportChildren(self, outfile, level, namespace_='', name_='LagrangianLinearTIDSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StepsInMemory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStepsInMemory>%s</%sStepsInMemory>%s' % (namespace_, self.gds_format_integer(self.StepsInMemory, input_name='StepsInMemory'), namespace_, eol_))
        if self.q is not None:
            self.q.export(outfile, level, namespace_, name_='q', pretty_print=pretty_print)
        if self.q0 is not None:
            self.q0.export(outfile, level, namespace_, name_='q0', pretty_print=pretty_print)
        if self.qMemory is not None:
            self.qMemory.export(outfile, level, namespace_, name_='qMemory', pretty_print=pretty_print)
        if self.Velocity is not None:
            self.Velocity.export(outfile, level, namespace_, name_='Velocity', pretty_print=pretty_print)
        if self.Velocity0 is not None:
            self.Velocity0.export(outfile, level, namespace_, name_='Velocity0', pretty_print=pretty_print)
        if self.VelocityMemory is not None:
            self.VelocityMemory.export(outfile, level, namespace_, name_='VelocityMemory', pretty_print=pretty_print)
        if self.FExt is not None:
            self.FExt.export(outfile, level, namespace_, name_='FExt', pretty_print=pretty_print)
        if self.Mass is not None:
            self.Mass.export(outfile, level, namespace_, name_='Mass', pretty_print=pretty_print)
        if self.K is not None:
            self.K.export(outfile, level, namespace_, name_='K', pretty_print=pretty_print)
        if self.C is not None:
            self.C.export(outfile, level, namespace_, name_='C', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LagrangianLinearTIDSType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            showIndent(outfile, level)
            outfile.write('number=%d,\n' % (self.number,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StepsInMemory is not None:
            showIndent(outfile, level)
            outfile.write('StepsInMemory=%d,\n' % self.StepsInMemory)
        if self.q is not None:
            showIndent(outfile, level)
            outfile.write('q=model_.vector(\n')
            self.q.exportLiteral(outfile, level, name_='q')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.q0 is not None:
            showIndent(outfile, level)
            outfile.write('q0=model_.vector(\n')
            self.q0.exportLiteral(outfile, level, name_='q0')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.qMemory is not None:
            showIndent(outfile, level)
            outfile.write('qMemory=model_.memory(\n')
            self.qMemory.exportLiteral(outfile, level, name_='qMemory')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Velocity is not None:
            showIndent(outfile, level)
            outfile.write('Velocity=model_.vector(\n')
            self.Velocity.exportLiteral(outfile, level, name_='Velocity')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Velocity0 is not None:
            showIndent(outfile, level)
            outfile.write('Velocity0=model_.vector(\n')
            self.Velocity0.exportLiteral(outfile, level, name_='Velocity0')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VelocityMemory is not None:
            showIndent(outfile, level)
            outfile.write('VelocityMemory=model_.memory(\n')
            self.VelocityMemory.exportLiteral(outfile, level, name_='VelocityMemory')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FExt is not None:
            showIndent(outfile, level)
            outfile.write('FExt=model_.vector(\n')
            self.FExt.exportLiteral(outfile, level, name_='FExt')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Mass is not None:
            showIndent(outfile, level)
            outfile.write('Mass=model_.matrix(\n')
            self.Mass.exportLiteral(outfile, level, name_='Mass')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.K is not None:
            showIndent(outfile, level)
            outfile.write('K=model_.matrix(\n')
            self.K.exportLiteral(outfile, level, name_='K')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.C is not None:
            showIndent(outfile, level)
            outfile.write('C=model_.matrix(\n')
            self.C.exportLiteral(outfile, level, name_='C')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            try:
                self.number = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StepsInMemory':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'StepsInMemory')
            self.StepsInMemory = ival_
        elif nodeName_ == 'q':
            obj_ = vector.factory()
            obj_.build(child_)
            self.q = obj_
        elif nodeName_ == 'q0':
            obj_ = vector.factory()
            obj_.build(child_)
            self.q0 = obj_
        elif nodeName_ == 'qMemory':
            obj_ = memory.factory()
            obj_.build(child_)
            self.qMemory = obj_
        elif nodeName_ == 'Velocity':
            obj_ = vector.factory()
            obj_.build(child_)
            self.Velocity = obj_
        elif nodeName_ == 'Velocity0':
            obj_ = vector.factory()
            obj_.build(child_)
            self.Velocity0 = obj_
        elif nodeName_ == 'VelocityMemory':
            obj_ = memory.factory()
            obj_.build(child_)
            self.VelocityMemory = obj_
        elif nodeName_ == 'FExt':
            obj_ = vector.factory()
            obj_.build(child_)
            self.FExt = obj_
        elif nodeName_ == 'Mass':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.Mass = obj_
        elif nodeName_ == 'K':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.K = obj_
        elif nodeName_ == 'C':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.C = obj_
# end class LagrangianLinearTIDSType


class Interaction_DefinitionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Interaction=None):
        if Interaction is None:
            self.Interaction = []
        else:
            self.Interaction = Interaction
    def factory(*args_, **kwargs_):
        if Interaction_DefinitionType.subclass:
            return Interaction_DefinitionType.subclass(*args_, **kwargs_)
        else:
            return Interaction_DefinitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Interaction(self): return self.Interaction
    def set_Interaction(self, Interaction): self.Interaction = Interaction
    def add_Interaction(self, value): self.Interaction.append(value)
    def insert_Interaction(self, index, value): self.Interaction[index] = value
    def hasContent_(self):
        if (
            self.Interaction
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Interaction_DefinitionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Interaction_DefinitionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Interaction_DefinitionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Interaction_DefinitionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Interaction_DefinitionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Interaction_ in self.Interaction:
            Interaction_.export(outfile, level, namespace_, name_='Interaction', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Interaction_DefinitionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Interaction=[\n')
        level += 1
        for Interaction_ in self.Interaction:
            showIndent(outfile, level)
            outfile.write('model_.InteractionType(\n')
            Interaction_.exportLiteral(outfile, level, name_='InteractionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Interaction':
            obj_ = InteractionType.factory()
            obj_.build(child_)
            self.Interaction.append(obj_)
# end class Interaction_DefinitionType


class InteractionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, number=None, size=None, y=None, lambda_=None, DS_Concerned=None, Interaction_Content=None):
        self.number = _cast(int, number)
        self.size = size
        self.y = y
        self.lambda_ = lambda_
        self.DS_Concerned = DS_Concerned
        self.Interaction_Content = Interaction_Content
    def factory(*args_, **kwargs_):
        if InteractionType.subclass:
            return InteractionType.subclass(*args_, **kwargs_)
        else:
            return InteractionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_lambda(self): return self.lambda_
    def set_lambda(self, lambda_): self.lambda_ = lambda_
    def get_DS_Concerned(self): return self.DS_Concerned
    def set_DS_Concerned(self, DS_Concerned): self.DS_Concerned = DS_Concerned
    def get_Interaction_Content(self): return self.Interaction_Content
    def set_Interaction_Content(self, Interaction_Content): self.Interaction_Content = Interaction_Content
    def get_number(self): return self.number
    def set_number(self, number): self.number = number
    def hasContent_(self):
        if (
            self.size is not None or
            self.y is not None or
            self.lambda_ is not None or
            self.DS_Concerned is not None or
            self.Interaction_Content is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InteractionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InteractionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InteractionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InteractionType'):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number="%s"' % self.gds_format_integer(self.number, input_name='number'))
    def exportChildren(self, outfile, level, namespace_='', name_='InteractionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.size is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssize>%s</%ssize>%s' % (namespace_, self.gds_format_integer(self.size, input_name='size'), namespace_, eol_))
        if self.y is not None:
            self.y.export(outfile, level, namespace_, name_='y', pretty_print=pretty_print)
        if self.lambda_ is not None:
            self.lambda_.export(outfile, level, namespace_, name_='lambda', pretty_print=pretty_print)
        if self.DS_Concerned is not None:
            self.DS_Concerned.export(outfile, level, namespace_, name_='DS_Concerned', pretty_print=pretty_print)
        if self.Interaction_Content is not None:
            self.Interaction_Content.export(outfile, level, namespace_, name_='Interaction_Content', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='InteractionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            showIndent(outfile, level)
            outfile.write('number=%d,\n' % (self.number,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('size=%d,\n' % self.size)
        if self.y is not None:
            showIndent(outfile, level)
            outfile.write('y=model_.vector(\n')
            self.y.exportLiteral(outfile, level, name_='y')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.lambda_ is not None:
            showIndent(outfile, level)
            outfile.write('lambda_=model_.vector(\n')
            self.lambda_.exportLiteral(outfile, level, name_='lambda')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DS_Concerned is not None:
            showIndent(outfile, level)
            outfile.write('DS_Concerned=model_.vector(\n')
            self.DS_Concerned.exportLiteral(outfile, level, name_='DS_Concerned')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Interaction_Content is not None:
            showIndent(outfile, level)
            outfile.write('Interaction_Content=model_.Interaction_ContentType(\n')
            self.Interaction_Content.exportLiteral(outfile, level, name_='Interaction_Content')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            try:
                self.number = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.number <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'size':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'size')
            self.size = ival_
        elif nodeName_ == 'y':
            obj_ = vector.factory()
            obj_.build(child_)
            self.y = obj_
        elif nodeName_ == 'lambda':
            obj_ = vector.factory()
            obj_.build(child_)
            self.lambda_ = obj_
        elif nodeName_ == 'DS_Concerned':
            obj_ = vector.factory()
            obj_.build(child_)
            self.DS_Concerned = obj_
        elif nodeName_ == 'Interaction_Content':
            obj_ = Interaction_ContentType.factory()
            obj_.build(child_)
            self.Interaction_Content = obj_
# end class InteractionType


class Interaction_ContentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FirstOrderRelation=None, FirstOrderLinearRelation=None, FirstOrderLinearTimeInvariantRelation=None, LagrangianRelation=None, LagrangianLinearRelation=None, Relay=None, NewtonImpactLaw=None, NewtonImpactFrictionLaw=None, ComplementarityCondition=None):
        self.FirstOrderRelation = FirstOrderRelation
        self.FirstOrderLinearRelation = FirstOrderLinearRelation
        self.FirstOrderLinearTimeInvariantRelation = FirstOrderLinearTimeInvariantRelation
        self.LagrangianRelation = LagrangianRelation
        self.LagrangianLinearRelation = LagrangianLinearRelation
        self.Relay = Relay
        self.NewtonImpactLaw = NewtonImpactLaw
        self.NewtonImpactFrictionLaw = NewtonImpactFrictionLaw
        self.ComplementarityCondition = ComplementarityCondition
    def factory(*args_, **kwargs_):
        if Interaction_ContentType.subclass:
            return Interaction_ContentType.subclass(*args_, **kwargs_)
        else:
            return Interaction_ContentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FirstOrderRelation(self): return self.FirstOrderRelation
    def set_FirstOrderRelation(self, FirstOrderRelation): self.FirstOrderRelation = FirstOrderRelation
    def get_FirstOrderLinearRelation(self): return self.FirstOrderLinearRelation
    def set_FirstOrderLinearRelation(self, FirstOrderLinearRelation): self.FirstOrderLinearRelation = FirstOrderLinearRelation
    def get_FirstOrderLinearTimeInvariantRelation(self): return self.FirstOrderLinearTimeInvariantRelation
    def set_FirstOrderLinearTimeInvariantRelation(self, FirstOrderLinearTimeInvariantRelation): self.FirstOrderLinearTimeInvariantRelation = FirstOrderLinearTimeInvariantRelation
    def get_LagrangianRelation(self): return self.LagrangianRelation
    def set_LagrangianRelation(self, LagrangianRelation): self.LagrangianRelation = LagrangianRelation
    def get_LagrangianLinearRelation(self): return self.LagrangianLinearRelation
    def set_LagrangianLinearRelation(self, LagrangianLinearRelation): self.LagrangianLinearRelation = LagrangianLinearRelation
    def get_Relay(self): return self.Relay
    def set_Relay(self, Relay): self.Relay = Relay
    def get_NewtonImpactLaw(self): return self.NewtonImpactLaw
    def set_NewtonImpactLaw(self, NewtonImpactLaw): self.NewtonImpactLaw = NewtonImpactLaw
    def get_NewtonImpactFrictionLaw(self): return self.NewtonImpactFrictionLaw
    def set_NewtonImpactFrictionLaw(self, NewtonImpactFrictionLaw): self.NewtonImpactFrictionLaw = NewtonImpactFrictionLaw
    def get_ComplementarityCondition(self): return self.ComplementarityCondition
    def set_ComplementarityCondition(self, ComplementarityCondition): self.ComplementarityCondition = ComplementarityCondition
    def hasContent_(self):
        if (
            self.FirstOrderRelation is not None or
            self.FirstOrderLinearRelation is not None or
            self.FirstOrderLinearTimeInvariantRelation is not None or
            self.LagrangianRelation is not None or
            self.LagrangianLinearRelation is not None or
            self.Relay is not None or
            self.NewtonImpactLaw is not None or
            self.NewtonImpactFrictionLaw is not None or
            self.ComplementarityCondition is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Interaction_ContentType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Interaction_ContentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Interaction_ContentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Interaction_ContentType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Interaction_ContentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FirstOrderRelation is not None:
            self.FirstOrderRelation.export(outfile, level, namespace_, name_='FirstOrderRelation', pretty_print=pretty_print)
        if self.FirstOrderLinearRelation is not None:
            self.FirstOrderLinearRelation.export(outfile, level, namespace_, name_='FirstOrderLinearRelation', pretty_print=pretty_print)
        if self.FirstOrderLinearTimeInvariantRelation is not None:
            self.FirstOrderLinearTimeInvariantRelation.export(outfile, level, namespace_, name_='FirstOrderLinearTimeInvariantRelation', pretty_print=pretty_print)
        if self.LagrangianRelation is not None:
            self.LagrangianRelation.export(outfile, level, namespace_, name_='LagrangianRelation', pretty_print=pretty_print)
        if self.LagrangianLinearRelation is not None:
            self.LagrangianLinearRelation.export(outfile, level, namespace_, name_='LagrangianLinearRelation', pretty_print=pretty_print)
        if self.Relay is not None:
            self.Relay.export(outfile, level, namespace_, name_='Relay', pretty_print=pretty_print)
        if self.NewtonImpactLaw is not None:
            self.NewtonImpactLaw.export(outfile, level, namespace_, name_='NewtonImpactLaw', pretty_print=pretty_print)
        if self.NewtonImpactFrictionLaw is not None:
            self.NewtonImpactFrictionLaw.export(outfile, level, namespace_, name_='NewtonImpactFrictionLaw', pretty_print=pretty_print)
        if self.ComplementarityCondition is not None:
            self.ComplementarityCondition.export(outfile, level, namespace_, name_='ComplementarityCondition', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Interaction_ContentType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FirstOrderRelation is not None:
            showIndent(outfile, level)
            outfile.write('FirstOrderRelation=model_.FirstOrderRelationType(\n')
            self.FirstOrderRelation.exportLiteral(outfile, level, name_='FirstOrderRelation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FirstOrderLinearRelation is not None:
            showIndent(outfile, level)
            outfile.write('FirstOrderLinearRelation=model_.FirstOrderLinearRelationType(\n')
            self.FirstOrderLinearRelation.exportLiteral(outfile, level, name_='FirstOrderLinearRelation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FirstOrderLinearTimeInvariantRelation is not None:
            showIndent(outfile, level)
            outfile.write('FirstOrderLinearTimeInvariantRelation=model_.FirstOrderLinearTimeInvariantRelationType(\n')
            self.FirstOrderLinearTimeInvariantRelation.exportLiteral(outfile, level, name_='FirstOrderLinearTimeInvariantRelation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LagrangianRelation is not None:
            showIndent(outfile, level)
            outfile.write('LagrangianRelation=model_.LagrangianRelationType(\n')
            self.LagrangianRelation.exportLiteral(outfile, level, name_='LagrangianRelation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LagrangianLinearRelation is not None:
            showIndent(outfile, level)
            outfile.write('LagrangianLinearRelation=model_.LagrangianLinearRelationType(\n')
            self.LagrangianLinearRelation.exportLiteral(outfile, level, name_='LagrangianLinearRelation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Relay is not None:
            showIndent(outfile, level)
            outfile.write('Relay=model_.RelayType(\n')
            self.Relay.exportLiteral(outfile, level, name_='Relay')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NewtonImpactLaw is not None:
            showIndent(outfile, level)
            outfile.write('NewtonImpactLaw=model_.NewtonImpactLawType(\n')
            self.NewtonImpactLaw.exportLiteral(outfile, level, name_='NewtonImpactLaw')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NewtonImpactFrictionLaw is not None:
            showIndent(outfile, level)
            outfile.write('NewtonImpactFrictionLaw=model_.NewtonImpactFrictionLawType(\n')
            self.NewtonImpactFrictionLaw.exportLiteral(outfile, level, name_='NewtonImpactFrictionLaw')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ComplementarityCondition is not None:
            showIndent(outfile, level)
            outfile.write('ComplementarityCondition=model_.ComplementarityConditionType(\n')
            self.ComplementarityCondition.exportLiteral(outfile, level, name_='ComplementarityCondition')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FirstOrderRelation':
            obj_ = FirstOrderRelationType.factory()
            obj_.build(child_)
            self.FirstOrderRelation = obj_
        elif nodeName_ == 'FirstOrderLinearRelation':
            obj_ = FirstOrderLinearRelationType.factory()
            obj_.build(child_)
            self.FirstOrderLinearRelation = obj_
        elif nodeName_ == 'FirstOrderLinearTimeInvariantRelation':
            obj_ = FirstOrderLinearTimeInvariantRelationType.factory()
            obj_.build(child_)
            self.FirstOrderLinearTimeInvariantRelation = obj_
        elif nodeName_ == 'LagrangianRelation':
            obj_ = LagrangianRelationType.factory()
            obj_.build(child_)
            self.LagrangianRelation = obj_
        elif nodeName_ == 'LagrangianLinearRelation':
            obj_ = LagrangianLinearRelationType.factory()
            obj_.build(child_)
            self.LagrangianLinearRelation = obj_
        elif nodeName_ == 'Relay':
            obj_ = RelayType.factory()
            obj_.build(child_)
            self.Relay = obj_
        elif nodeName_ == 'NewtonImpactLaw':
            obj_ = NewtonImpactLawType.factory()
            obj_.build(child_)
            self.NewtonImpactLaw = obj_
        elif nodeName_ == 'NewtonImpactFrictionLaw':
            obj_ = NewtonImpactFrictionLawType.factory()
            obj_.build(child_)
            self.NewtonImpactFrictionLaw = obj_
        elif nodeName_ == 'ComplementarityCondition':
            obj_ = ComplementarityConditionType.factory()
            obj_.build(child_)
            self.ComplementarityCondition = obj_
# end class Interaction_ContentType


class FirstOrderRelationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_='Undefined', h=None, g=None, jacobianG=None, jacobianH=None):
        self.type_ = _cast(None, type_)
        self.h = h
        self.g = g
        self.jacobianG = jacobianG
        self.jacobianH = jacobianH
    def factory(*args_, **kwargs_):
        if FirstOrderRelationType.subclass:
            return FirstOrderRelationType.subclass(*args_, **kwargs_)
        else:
            return FirstOrderRelationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_h(self): return self.h
    def set_h(self, h): self.h = h
    def get_g(self): return self.g
    def set_g(self, g): self.g = g
    def get_jacobianG(self): return self.jacobianG
    def set_jacobianG(self, jacobianG): self.jacobianG = jacobianG
    def get_jacobianH(self): return self.jacobianH
    def set_jacobianH(self, jacobianH): self.jacobianH = jacobianH
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.h is not None or
            self.g is not None or
            self.jacobianG is not None or
            self.jacobianH is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FirstOrderRelationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FirstOrderRelationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FirstOrderRelationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FirstOrderRelationType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FirstOrderRelationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.h is not None:
            self.h.export(outfile, level, namespace_, name_='h', pretty_print=pretty_print)
        if self.g is not None:
            self.g.export(outfile, level, namespace_, name_='g', pretty_print=pretty_print)
        if self.jacobianG is not None:
            self.jacobianG.export(outfile, level, namespace_, name_='jacobianG', pretty_print=pretty_print)
        if self.jacobianH is not None:
            self.jacobianH.export(outfile, level, namespace_, name_='jacobianH', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FirstOrderRelationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.h is not None:
            showIndent(outfile, level)
            outfile.write('h=model_.pluginDef(\n')
            self.h.exportLiteral(outfile, level, name_='h')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.g is not None:
            showIndent(outfile, level)
            outfile.write('g=model_.pluginDef(\n')
            self.g.exportLiteral(outfile, level, name_='g')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.jacobianG is not None:
            showIndent(outfile, level)
            outfile.write('jacobianG=model_.listOfMatrices(\n')
            self.jacobianG.exportLiteral(outfile, level, name_='jacobianG')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.jacobianH is not None:
            showIndent(outfile, level)
            outfile.write('jacobianH=model_.listOfMatrices(\n')
            self.jacobianH.exportLiteral(outfile, level, name_='jacobianH')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'h':
            obj_ = pluginDef.factory()
            obj_.build(child_)
            self.h = obj_
        elif nodeName_ == 'g':
            obj_ = pluginDef.factory()
            obj_.build(child_)
            self.g = obj_
        elif nodeName_ == 'jacobianG':
            obj_ = listOfMatrices.factory()
            obj_.build(child_)
            self.jacobianG = obj_
        elif nodeName_ == 'jacobianH':
            obj_ = listOfMatrices.factory()
            obj_.build(child_)
            self.jacobianH = obj_
# end class FirstOrderRelationType


class FirstOrderLinearRelationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_='Undefined', C=None, D=None, F=None, e=None, B=None):
        self.type_ = _cast(None, type_)
        self.C = C
        self.D = D
        self.F = F
        self.e = e
        self.B = B
    def factory(*args_, **kwargs_):
        if FirstOrderLinearRelationType.subclass:
            return FirstOrderLinearRelationType.subclass(*args_, **kwargs_)
        else:
            return FirstOrderLinearRelationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_C(self): return self.C
    def set_C(self, C): self.C = C
    def get_D(self): return self.D
    def set_D(self, D): self.D = D
    def get_F(self): return self.F
    def set_F(self, F): self.F = F
    def get_e(self): return self.e
    def set_e(self, e): self.e = e
    def get_B(self): return self.B
    def set_B(self, B): self.B = B
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.C is not None or
            self.D is not None or
            self.F is not None or
            self.e is not None or
            self.B is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FirstOrderLinearRelationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FirstOrderLinearRelationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FirstOrderLinearRelationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FirstOrderLinearRelationType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FirstOrderLinearRelationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.C is not None:
            self.C.export(outfile, level, namespace_, name_='C', pretty_print=pretty_print)
        if self.D is not None:
            self.D.export(outfile, level, namespace_, name_='D', pretty_print=pretty_print)
        if self.F is not None:
            self.F.export(outfile, level, namespace_, name_='F', pretty_print=pretty_print)
        if self.e is not None:
            self.e.export(outfile, level, namespace_, name_='e', pretty_print=pretty_print)
        if self.B is not None:
            self.B.export(outfile, level, namespace_, name_='B', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FirstOrderLinearRelationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.C is not None:
            showIndent(outfile, level)
            outfile.write('C=model_.matrix(\n')
            self.C.exportLiteral(outfile, level, name_='C')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.D is not None:
            showIndent(outfile, level)
            outfile.write('D=model_.matrix(\n')
            self.D.exportLiteral(outfile, level, name_='D')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.F is not None:
            showIndent(outfile, level)
            outfile.write('F=model_.matrix(\n')
            self.F.exportLiteral(outfile, level, name_='F')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.e is not None:
            showIndent(outfile, level)
            outfile.write('e=model_.vector(\n')
            self.e.exportLiteral(outfile, level, name_='e')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.B is not None:
            showIndent(outfile, level)
            outfile.write('B=model_.matrix(\n')
            self.B.exportLiteral(outfile, level, name_='B')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'C':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.C = obj_
        elif nodeName_ == 'D':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.D = obj_
        elif nodeName_ == 'F':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.F = obj_
        elif nodeName_ == 'e':
            obj_ = vector.factory()
            obj_.build(child_)
            self.e = obj_
        elif nodeName_ == 'B':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.B = obj_
# end class FirstOrderLinearRelationType


class FirstOrderLinearTimeInvariantRelationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_='Undefined', C=None, D=None, F=None, e=None, B=None):
        self.type_ = _cast(None, type_)
        self.C = C
        self.D = D
        self.F = F
        self.e = e
        self.B = B
    def factory(*args_, **kwargs_):
        if FirstOrderLinearTimeInvariantRelationType.subclass:
            return FirstOrderLinearTimeInvariantRelationType.subclass(*args_, **kwargs_)
        else:
            return FirstOrderLinearTimeInvariantRelationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_C(self): return self.C
    def set_C(self, C): self.C = C
    def get_D(self): return self.D
    def set_D(self, D): self.D = D
    def get_F(self): return self.F
    def set_F(self, F): self.F = F
    def get_e(self): return self.e
    def set_e(self, e): self.e = e
    def get_B(self): return self.B
    def set_B(self, B): self.B = B
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.C is not None or
            self.D is not None or
            self.F is not None or
            self.e is not None or
            self.B is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FirstOrderLinearTimeInvariantRelationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FirstOrderLinearTimeInvariantRelationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FirstOrderLinearTimeInvariantRelationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FirstOrderLinearTimeInvariantRelationType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FirstOrderLinearTimeInvariantRelationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.C is not None:
            self.C.export(outfile, level, namespace_, name_='C', pretty_print=pretty_print)
        if self.D is not None:
            self.D.export(outfile, level, namespace_, name_='D', pretty_print=pretty_print)
        if self.F is not None:
            self.F.export(outfile, level, namespace_, name_='F', pretty_print=pretty_print)
        if self.e is not None:
            self.e.export(outfile, level, namespace_, name_='e', pretty_print=pretty_print)
        if self.B is not None:
            self.B.export(outfile, level, namespace_, name_='B', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FirstOrderLinearTimeInvariantRelationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.C is not None:
            showIndent(outfile, level)
            outfile.write('C=model_.matrix(\n')
            self.C.exportLiteral(outfile, level, name_='C')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.D is not None:
            showIndent(outfile, level)
            outfile.write('D=model_.matrix(\n')
            self.D.exportLiteral(outfile, level, name_='D')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.F is not None:
            showIndent(outfile, level)
            outfile.write('F=model_.matrix(\n')
            self.F.exportLiteral(outfile, level, name_='F')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.e is not None:
            showIndent(outfile, level)
            outfile.write('e=model_.vector(\n')
            self.e.exportLiteral(outfile, level, name_='e')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.B is not None:
            showIndent(outfile, level)
            outfile.write('B=model_.matrix(\n')
            self.B.exportLiteral(outfile, level, name_='B')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'C':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.C = obj_
        elif nodeName_ == 'D':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.D = obj_
        elif nodeName_ == 'F':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.F = obj_
        elif nodeName_ == 'e':
            obj_ = vector.factory()
            obj_.build(child_)
            self.e = obj_
        elif nodeName_ == 'B':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.B = obj_
# end class FirstOrderLinearTimeInvariantRelationType


class LagrangianRelationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_='Undefined', h=None, jacobianH=None, C=None):
        self.type_ = _cast(None, type_)
        self.h = h
        self.jacobianH = jacobianH
        self.C = C
    def factory(*args_, **kwargs_):
        if LagrangianRelationType.subclass:
            return LagrangianRelationType.subclass(*args_, **kwargs_)
        else:
            return LagrangianRelationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_h(self): return self.h
    def set_h(self, h): self.h = h
    def get_jacobianH(self): return self.jacobianH
    def set_jacobianH(self, jacobianH): self.jacobianH = jacobianH
    def get_C(self): return self.C
    def set_C(self, C): self.C = C
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.h is not None or
            self.jacobianH is not None or
            self.C is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LagrangianRelationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LagrangianRelationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LagrangianRelationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LagrangianRelationType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LagrangianRelationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.h is not None:
            self.h.export(outfile, level, namespace_, name_='h', pretty_print=pretty_print)
        if self.jacobianH is not None:
            self.jacobianH.export(outfile, level, namespace_, name_='jacobianH', pretty_print=pretty_print)
        if self.C is not None:
            self.C.export(outfile, level, namespace_, name_='C', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LagrangianRelationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.h is not None:
            showIndent(outfile, level)
            outfile.write('h=model_.pluginDef(\n')
            self.h.exportLiteral(outfile, level, name_='h')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.jacobianH is not None:
            showIndent(outfile, level)
            outfile.write('jacobianH=model_.listOfMatrices(\n')
            self.jacobianH.exportLiteral(outfile, level, name_='jacobianH')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.C is not None:
            showIndent(outfile, level)
            outfile.write('C=model_.matrix(\n')
            self.C.exportLiteral(outfile, level, name_='C')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'h':
            obj_ = pluginDef.factory()
            obj_.build(child_)
            self.h = obj_
        elif nodeName_ == 'jacobianH':
            obj_ = listOfMatrices.factory()
            obj_.build(child_)
            self.jacobianH = obj_
        elif nodeName_ == 'C':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.C = obj_
# end class LagrangianRelationType


class LagrangianLinearRelationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_='Undefined', H=None, b=None, D=None, F=None):
        self.type_ = _cast(None, type_)
        self.H = H
        self.b = b
        self.D = D
        self.F = F
    def factory(*args_, **kwargs_):
        if LagrangianLinearRelationType.subclass:
            return LagrangianLinearRelationType.subclass(*args_, **kwargs_)
        else:
            return LagrangianLinearRelationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_H(self): return self.H
    def set_H(self, H): self.H = H
    def get_b(self): return self.b
    def set_b(self, b): self.b = b
    def get_D(self): return self.D
    def set_D(self, D): self.D = D
    def get_F(self): return self.F
    def set_F(self, F): self.F = F
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.H is not None or
            self.b is not None or
            self.D is not None or
            self.F is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LagrangianLinearRelationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LagrangianLinearRelationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LagrangianLinearRelationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LagrangianLinearRelationType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LagrangianLinearRelationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.H is not None:
            self.H.export(outfile, level, namespace_, name_='H', pretty_print=pretty_print)
        if self.b is not None:
            self.b.export(outfile, level, namespace_, name_='b', pretty_print=pretty_print)
        if self.D is not None:
            self.D.export(outfile, level, namespace_, name_='D', pretty_print=pretty_print)
        if self.F is not None:
            self.F.export(outfile, level, namespace_, name_='F', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LagrangianLinearRelationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.H is not None:
            showIndent(outfile, level)
            outfile.write('H=model_.matrix(\n')
            self.H.exportLiteral(outfile, level, name_='H')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.b is not None:
            showIndent(outfile, level)
            outfile.write('b=model_.vector(\n')
            self.b.exportLiteral(outfile, level, name_='b')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.D is not None:
            showIndent(outfile, level)
            outfile.write('D=model_.matrix(\n')
            self.D.exportLiteral(outfile, level, name_='D')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.F is not None:
            showIndent(outfile, level)
            outfile.write('F=model_.matrix(\n')
            self.F.exportLiteral(outfile, level, name_='F')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'H':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.H = obj_
        elif nodeName_ == 'b':
            obj_ = vector.factory()
            obj_.build(child_)
            self.b = obj_
        elif nodeName_ == 'D':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.D = obj_
        elif nodeName_ == 'F':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.F = obj_
# end class LagrangianLinearRelationType


class RelayType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, c=None, d=None, size=None):
        self.c = c
        self.d = d
        self.size = size
    def factory(*args_, **kwargs_):
        if RelayType.subclass:
            return RelayType.subclass(*args_, **kwargs_)
        else:
            return RelayType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_c(self): return self.c
    def set_c(self, c): self.c = c
    def get_d(self): return self.d
    def set_d(self, d): self.d = d
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def hasContent_(self):
        if (
            self.c is not None or
            self.d is not None or
            self.size is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RelayType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelayType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RelayType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RelayType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RelayType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.c is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sc>%s</%sc>%s' % (namespace_, self.gds_format_double(self.c, input_name='c'), namespace_, eol_))
        if self.d is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sd>%s</%sd>%s' % (namespace_, self.gds_format_double(self.d, input_name='d'), namespace_, eol_))
        if self.size is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssize>%s</%ssize>%s' % (namespace_, self.gds_format_integer(self.size, input_name='size'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='RelayType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.c is not None:
            showIndent(outfile, level)
            outfile.write('c=%e,\n' % self.c)
        if self.d is not None:
            showIndent(outfile, level)
            outfile.write('d=%e,\n' % self.d)
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('size=%d,\n' % self.size)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'c':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'c')
            self.c = fval_
        elif nodeName_ == 'd':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'd')
            self.d = fval_
        elif nodeName_ == 'size':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'size')
            self.size = ival_
# end class RelayType


class NewtonImpactLawType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, e=None, size=None):
        self.e = e
        self.size = size
    def factory(*args_, **kwargs_):
        if NewtonImpactLawType.subclass:
            return NewtonImpactLawType.subclass(*args_, **kwargs_)
        else:
            return NewtonImpactLawType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_e(self): return self.e
    def set_e(self, e): self.e = e
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def hasContent_(self):
        if (
            self.e is not None or
            self.size is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NewtonImpactLawType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NewtonImpactLawType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NewtonImpactLawType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NewtonImpactLawType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NewtonImpactLawType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.e is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%se>%s</%se>%s' % (namespace_, self.gds_format_double(self.e, input_name='e'), namespace_, eol_))
        if self.size is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssize>%s</%ssize>%s' % (namespace_, self.gds_format_integer(self.size, input_name='size'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='NewtonImpactLawType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.e is not None:
            showIndent(outfile, level)
            outfile.write('e=%e,\n' % self.e)
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('size=%d,\n' % self.size)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'e':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'e')
            self.e = fval_
        elif nodeName_ == 'size':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'size')
            self.size = ival_
# end class NewtonImpactLawType


class NewtonImpactFrictionLawType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, en=None, et=None, mu=None, size=None):
        self.en = en
        self.et = et
        self.mu = mu
        self.size = size
    def factory(*args_, **kwargs_):
        if NewtonImpactFrictionLawType.subclass:
            return NewtonImpactFrictionLawType.subclass(*args_, **kwargs_)
        else:
            return NewtonImpactFrictionLawType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_en(self): return self.en
    def set_en(self, en): self.en = en
    def get_et(self): return self.et
    def set_et(self, et): self.et = et
    def get_mu(self): return self.mu
    def set_mu(self, mu): self.mu = mu
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def hasContent_(self):
        if (
            self.en is not None or
            self.et is not None or
            self.mu is not None or
            self.size is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NewtonImpactFrictionLawType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NewtonImpactFrictionLawType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NewtonImpactFrictionLawType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NewtonImpactFrictionLawType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NewtonImpactFrictionLawType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.en is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sen>%s</%sen>%s' % (namespace_, self.gds_format_double(self.en, input_name='en'), namespace_, eol_))
        if self.et is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%set>%s</%set>%s' % (namespace_, self.gds_format_double(self.et, input_name='et'), namespace_, eol_))
        if self.mu is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smu>%s</%smu>%s' % (namespace_, self.gds_format_double(self.mu, input_name='mu'), namespace_, eol_))
        if self.size is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssize>%s</%ssize>%s' % (namespace_, self.gds_format_integer(self.size, input_name='size'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='NewtonImpactFrictionLawType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.en is not None:
            showIndent(outfile, level)
            outfile.write('en=%e,\n' % self.en)
        if self.et is not None:
            showIndent(outfile, level)
            outfile.write('et=%e,\n' % self.et)
        if self.mu is not None:
            showIndent(outfile, level)
            outfile.write('mu=%e,\n' % self.mu)
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('size=%d,\n' % self.size)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'en':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'en')
            self.en = fval_
        elif nodeName_ == 'et':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'et')
            self.et = fval_
        elif nodeName_ == 'mu':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'mu')
            self.mu = fval_
        elif nodeName_ == 'size':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'size')
            self.size = ival_
# end class NewtonImpactFrictionLawType


class ComplementarityConditionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, size=None):
        self.size = size
    def factory(*args_, **kwargs_):
        if ComplementarityConditionType.subclass:
            return ComplementarityConditionType.subclass(*args_, **kwargs_)
        else:
            return ComplementarityConditionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def hasContent_(self):
        if (
            self.size is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ComplementarityConditionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ComplementarityConditionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ComplementarityConditionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ComplementarityConditionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ComplementarityConditionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.size is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssize>%s</%ssize>%s' % (namespace_, self.gds_format_integer(self.size, input_name='size'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ComplementarityConditionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('size=%d,\n' % self.size)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'size':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'size')
            self.size = ival_
# end class ComplementarityConditionType


class SimulationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, TimeDiscretisation=None, OneStepIntegrator_LMGC90=None, OneStepIntegrator_Definition=None, OneStepNSProblems_List=None):
        self.type_ = _cast(None, type_)
        self.TimeDiscretisation = TimeDiscretisation
        self.OneStepIntegrator_LMGC90 = OneStepIntegrator_LMGC90
        self.OneStepIntegrator_Definition = OneStepIntegrator_Definition
        self.OneStepNSProblems_List = OneStepNSProblems_List
    def factory(*args_, **kwargs_):
        if SimulationType.subclass:
            return SimulationType.subclass(*args_, **kwargs_)
        else:
            return SimulationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TimeDiscretisation(self): return self.TimeDiscretisation
    def set_TimeDiscretisation(self, TimeDiscretisation): self.TimeDiscretisation = TimeDiscretisation
    def get_OneStepIntegrator_LMGC90(self): return self.OneStepIntegrator_LMGC90
    def set_OneStepIntegrator_LMGC90(self, OneStepIntegrator_LMGC90): self.OneStepIntegrator_LMGC90 = OneStepIntegrator_LMGC90
    def get_OneStepIntegrator_Definition(self): return self.OneStepIntegrator_Definition
    def set_OneStepIntegrator_Definition(self, OneStepIntegrator_Definition): self.OneStepIntegrator_Definition = OneStepIntegrator_Definition
    def get_OneStepNSProblems_List(self): return self.OneStepNSProblems_List
    def set_OneStepNSProblems_List(self, OneStepNSProblems_List): self.OneStepNSProblems_List = OneStepNSProblems_List
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def validate_PossibleSimulationValues(self, value):
        # Validate type PossibleSimulationValues, a restriction on xsd:string.
        pass
    def hasContent_(self):
        if (
            self.TimeDiscretisation is not None or
            self.OneStepIntegrator_LMGC90 is not None or
            self.OneStepIntegrator_Definition is not None or
            self.OneStepNSProblems_List is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SimulationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimulationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SimulationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SimulationType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SimulationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TimeDiscretisation is not None:
            self.TimeDiscretisation.export(outfile, level, namespace_, name_='TimeDiscretisation', pretty_print=pretty_print)
        if self.OneStepIntegrator_LMGC90 is not None:
            self.OneStepIntegrator_LMGC90.export(outfile, level, namespace_, name_='OneStepIntegrator_LMGC90', pretty_print=pretty_print)
        if self.OneStepIntegrator_Definition is not None:
            self.OneStepIntegrator_Definition.export(outfile, level, namespace_, name_='OneStepIntegrator_Definition', pretty_print=pretty_print)
        if self.OneStepNSProblems_List is not None:
            self.OneStepNSProblems_List.export(outfile, level, namespace_, name_='OneStepNSProblems_List', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SimulationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TimeDiscretisation is not None:
            showIndent(outfile, level)
            outfile.write('TimeDiscretisation=model_.TimeDiscretisationType(\n')
            self.TimeDiscretisation.exportLiteral(outfile, level, name_='TimeDiscretisation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OneStepIntegrator_LMGC90 is not None:
            showIndent(outfile, level)
            outfile.write('OneStepIntegrator_LMGC90=model_.OneStepIntegrator_LMGC90Type(\n')
            self.OneStepIntegrator_LMGC90.exportLiteral(outfile, level, name_='OneStepIntegrator_LMGC90')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OneStepIntegrator_Definition is not None:
            showIndent(outfile, level)
            outfile.write('OneStepIntegrator_Definition=model_.OneStepIntegrator_DefinitionType(\n')
            self.OneStepIntegrator_Definition.exportLiteral(outfile, level, name_='OneStepIntegrator_Definition')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OneStepNSProblems_List is not None:
            showIndent(outfile, level)
            outfile.write('OneStepNSProblems_List=model_.OneStepNSProblems_ListType(\n')
            self.OneStepNSProblems_List.exportLiteral(outfile, level, name_='OneStepNSProblems_List')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_PossibleSimulationValues(self.type_)    # validate type PossibleSimulationValues
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TimeDiscretisation':
            obj_ = TimeDiscretisationType.factory()
            obj_.build(child_)
            self.TimeDiscretisation = obj_
        elif nodeName_ == 'OneStepIntegrator_LMGC90':
            obj_ = OneStepIntegrator_LMGC90Type.factory()
            obj_.build(child_)
            self.OneStepIntegrator_LMGC90 = obj_
        elif nodeName_ == 'OneStepIntegrator_Definition':
            obj_ = OneStepIntegrator_DefinitionType.factory()
            obj_.build(child_)
            self.OneStepIntegrator_Definition = obj_
        elif nodeName_ == 'OneStepNSProblems_List':
            obj_ = OneStepNSProblems_ListType.factory()
            obj_.build(child_)
            self.OneStepNSProblems_List = obj_
# end class SimulationType


class TimeDiscretisationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, isConstant=None, h=None, N=None, tk=None, hMin=None, hMax=None):
        self.isConstant = _cast(None, isConstant)
        self.h = h
        self.N = N
        self.tk = tk
        self.hMin = hMin
        self.hMax = hMax
    def factory(*args_, **kwargs_):
        if TimeDiscretisationType.subclass:
            return TimeDiscretisationType.subclass(*args_, **kwargs_)
        else:
            return TimeDiscretisationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_h(self): return self.h
    def set_h(self, h): self.h = h
    def get_N(self): return self.N
    def set_N(self, N): self.N = N
    def get_tk(self): return self.tk
    def set_tk(self, tk): self.tk = tk
    def get_hMin(self): return self.hMin
    def set_hMin(self, hMin): self.hMin = hMin
    def get_hMax(self): return self.hMax
    def set_hMax(self, hMax): self.hMax = hMax
    def get_isConstant(self): return self.isConstant
    def set_isConstant(self, isConstant): self.isConstant = isConstant
    def validate_positiveDouble(self, value):
        # Validate type positiveDouble, a restriction on xsd:double.
        pass
    def validate_boolean(self, value):
        # Validate type boolean, a restriction on xsd:boolean.
        pass
    def hasContent_(self):
        if (
            self.h is not None or
            self.N is not None or
            self.tk is not None or
            self.hMin is not None or
            self.hMax is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TimeDiscretisationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeDiscretisationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TimeDiscretisationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeDiscretisationType'):
        if self.isConstant is not None and 'isConstant' not in already_processed:
            already_processed.add('isConstant')
            outfile.write(' isConstant=%s' % (quote_attrib(self.isConstant), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TimeDiscretisationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.h is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sh>%s</%sh>%s' % (namespace_, self.gds_format_double(self.h, input_name='h'), namespace_, eol_))
        if self.N is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sN>%s</%sN>%s' % (namespace_, self.gds_format_integer(self.N, input_name='N'), namespace_, eol_))
        if self.tk is not None:
            self.tk.export(outfile, level, namespace_, name_='tk', pretty_print=pretty_print)
        if self.hMin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shMin>%s</%shMin>%s' % (namespace_, self.gds_format_double(self.hMin, input_name='hMin'), namespace_, eol_))
        if self.hMax is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shMax>%s</%shMax>%s' % (namespace_, self.gds_format_double(self.hMax, input_name='hMax'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='TimeDiscretisationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isConstant is not None and 'isConstant' not in already_processed:
            already_processed.add('isConstant')
            showIndent(outfile, level)
            outfile.write('isConstant=%s,\n' % (self.isConstant,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.h is not None:
            showIndent(outfile, level)
            outfile.write('h=%e,\n' % self.h)
        if self.N is not None:
            showIndent(outfile, level)
            outfile.write('N=%d,\n' % self.N)
        if self.tk is not None:
            showIndent(outfile, level)
            outfile.write('tk=model_.vector(\n')
            self.tk.exportLiteral(outfile, level, name_='tk')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.hMin is not None:
            showIndent(outfile, level)
            outfile.write('hMin=%e,\n' % self.hMin)
        if self.hMax is not None:
            showIndent(outfile, level)
            outfile.write('hMax=%e,\n' % self.hMax)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isConstant', node)
        if value is not None and 'isConstant' not in already_processed:
            already_processed.add('isConstant')
            if value in ('true', '1'):
                self.isConstant = True
            elif value in ('false', '0'):
                self.isConstant = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
            self.validate_boolean(self.isConstant)    # validate type boolean
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'h':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'h')
            self.h = fval_
            self.validate_positiveDouble(self.h)    # validate type positiveDouble
        elif nodeName_ == 'N':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'N')
            self.N = ival_
        elif nodeName_ == 'tk':
            obj_ = vector.factory()
            obj_.build(child_)
            self.tk = obj_
        elif nodeName_ == 'hMin':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'hMin')
            self.hMin = fval_
            self.validate_positiveDouble(self.hMin)    # validate type positiveDouble
        elif nodeName_ == 'hMax':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'hMax')
            self.hMax = fval_
            self.validate_positiveDouble(self.hMax)    # validate type positiveDouble
# end class TimeDiscretisationType


class OneStepIntegrator_LMGC90Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, empty=None):
        self.empty = empty
    def factory(*args_, **kwargs_):
        if OneStepIntegrator_LMGC90Type.subclass:
            return OneStepIntegrator_LMGC90Type.subclass(*args_, **kwargs_)
        else:
            return OneStepIntegrator_LMGC90Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_empty(self): return self.empty
    def set_empty(self, empty): self.empty = empty
    def hasContent_(self):
        if (
            self.empty is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OneStepIntegrator_LMGC90Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OneStepIntegrator_LMGC90Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OneStepIntegrator_LMGC90Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OneStepIntegrator_LMGC90Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OneStepIntegrator_LMGC90Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.empty is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sempty>%s</%sempty>%s' % (namespace_, self.gds_format_string(quote_xml(self.empty).encode(ExternalEncoding), input_name='empty'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='OneStepIntegrator_LMGC90Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.empty is not None:
            showIndent(outfile, level)
            outfile.write('empty=%s,\n' % quote_python(self.empty).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'empty':
            empty_ = child_.text
            empty_ = self.gds_validate_string(empty_, node, 'empty')
            self.empty = empty_
# end class OneStepIntegrator_LMGC90Type


class OneStepIntegrator_DefinitionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MoreauJeanOSI=None, LsodarOSI=None):
        if MoreauJeanOSI is None:
            self.MoreauJeanOSI = []
        else:
            self.MoreauJeanOSI = MoreauJeanOSI
        if LsodarOSI is None:
            self.LsodarOSI = []
        else:
            self.LsodarOSI = LsodarOSI
    def factory(*args_, **kwargs_):
        if OneStepIntegrator_DefinitionType.subclass:
            return OneStepIntegrator_DefinitionType.subclass(*args_, **kwargs_)
        else:
            return OneStepIntegrator_DefinitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MoreauJeanOSI(self): return self.MoreauJeanOSI
    def set_MoreauJeanOSI(self, MoreauJeanOSI): self.MoreauJeanOSI = MoreauJeanOSI
    def add_MoreauJeanOSI(self, value): self.MoreauJeanOSI.append(value)
    def insert_MoreauJeanOSI(self, index, value): self.MoreauJeanOSI[index] = value
    def get_LsodarOSI(self): return self.LsodarOSI
    def set_LsodarOSI(self, LsodarOSI): self.LsodarOSI = LsodarOSI
    def add_LsodarOSI(self, value): self.LsodarOSI.append(value)
    def insert_LsodarOSI(self, index, value): self.LsodarOSI[index] = value
    def hasContent_(self):
        if (
            self.MoreauJeanOSI or
            self.LsodarOSI
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OneStepIntegrator_DefinitionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OneStepIntegrator_DefinitionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OneStepIntegrator_DefinitionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OneStepIntegrator_DefinitionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OneStepIntegrator_DefinitionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MoreauJeanOSI_ in self.MoreauJeanOSI:
            MoreauJeanOSI_.export(outfile, level, namespace_, name_='MoreauJeanOSI', pretty_print=pretty_print)
        for LsodarOSI_ in self.LsodarOSI:
            LsodarOSI_.export(outfile, level, namespace_, name_='LsodarOSI', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='OneStepIntegrator_DefinitionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('MoreauJeanOSI=[\n')
        level += 1
        for MoreauJeanOSI_ in self.MoreauJeanOSI:
            showIndent(outfile, level)
            outfile.write('model_.MoreauJeanOSIType(\n')
            MoreauJeanOSI_.exportLiteral(outfile, level, name_='MoreauJeanOSIType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LsodarOSI=[\n')
        level += 1
        for LsodarOSI_ in self.LsodarOSI:
            showIndent(outfile, level)
            outfile.write('model_.LsodarOSIType(\n')
            LsodarOSI_.exportLiteral(outfile, level, name_='LsodarOSIType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MoreauJeanOSI':
            obj_ = MoreauJeanOSIType.factory()
            obj_.build(child_)
            self.MoreauJeanOSI.append(obj_)
        elif nodeName_ == 'LsodarOSI':
            obj_ = LsodarOSIType.factory()
            obj_.build(child_)
            self.LsodarOSI.append(obj_)
# end class OneStepIntegrator_DefinitionType


class MoreauJeanOSIType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DS_Concerned=None, Interactions_Concerned=None, Theta=None):
        self.DS_Concerned = DS_Concerned
        self.Interactions_Concerned = Interactions_Concerned
        self.Theta = Theta
    def factory(*args_, **kwargs_):
        if MoreauJeanOSIType.subclass:
            return MoreauJeanOSIType.subclass(*args_, **kwargs_)
        else:
            return MoreauJeanOSIType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DS_Concerned(self): return self.DS_Concerned
    def set_DS_Concerned(self, DS_Concerned): self.DS_Concerned = DS_Concerned
    def get_Interactions_Concerned(self): return self.Interactions_Concerned
    def set_Interactions_Concerned(self, Interactions_Concerned): self.Interactions_Concerned = Interactions_Concerned
    def get_Theta(self): return self.Theta
    def set_Theta(self, Theta): self.Theta = Theta
    def hasContent_(self):
        if (
            self.DS_Concerned is not None or
            self.Interactions_Concerned is not None or
            self.Theta is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MoreauJeanOSIType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MoreauJeanOSIType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MoreauJeanOSIType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MoreauJeanOSIType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MoreauJeanOSIType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DS_Concerned is not None:
            self.DS_Concerned.export(outfile, level, namespace_, name_='DS_Concerned', pretty_print=pretty_print)
        if self.Interactions_Concerned is not None:
            self.Interactions_Concerned.export(outfile, level, namespace_, name_='Interactions_Concerned', pretty_print=pretty_print)
        if self.Theta is not None:
            self.Theta.export(outfile, level, namespace_, name_='Theta', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MoreauJeanOSIType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DS_Concerned is not None:
            showIndent(outfile, level)
            outfile.write('DS_Concerned=model_.vector(\n')
            self.DS_Concerned.exportLiteral(outfile, level, name_='DS_Concerned')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Interactions_Concerned is not None:
            showIndent(outfile, level)
            outfile.write('Interactions_Concerned=model_.vector(\n')
            self.Interactions_Concerned.exportLiteral(outfile, level, name_='Interactions_Concerned')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Theta is not None:
            showIndent(outfile, level)
            outfile.write('Theta=model_.emptyType(\n')
            self.Theta.exportLiteral(outfile, level, name_='Theta')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DS_Concerned':
            obj_ = vector.factory()
            obj_.build(child_)
            self.DS_Concerned = obj_
        elif nodeName_ == 'Interactions_Concerned':
            obj_ = vector.factory()
            obj_.build(child_)
            self.Interactions_Concerned = obj_
        elif nodeName_ == 'Theta':
            obj_ = emptyType.factory()
            obj_.build(child_)
            self.Theta = obj_
# end class MoreauJeanOSIType


class LsodarOSIType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DS_Concerned=None, Interactions_Concerned=None):
        self.DS_Concerned = DS_Concerned
        self.Interactions_Concerned = Interactions_Concerned
    def factory(*args_, **kwargs_):
        if LsodarOSIType.subclass:
            return LsodarOSIType.subclass(*args_, **kwargs_)
        else:
            return LsodarOSIType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DS_Concerned(self): return self.DS_Concerned
    def set_DS_Concerned(self, DS_Concerned): self.DS_Concerned = DS_Concerned
    def get_Interactions_Concerned(self): return self.Interactions_Concerned
    def set_Interactions_Concerned(self, Interactions_Concerned): self.Interactions_Concerned = Interactions_Concerned
    def hasContent_(self):
        if (
            self.DS_Concerned is not None or
            self.Interactions_Concerned is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LsodarOSIType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LsodarOSIType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LsodarOSIType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LsodarOSIType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LsodarOSIType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DS_Concerned is not None:
            self.DS_Concerned.export(outfile, level, namespace_, name_='DS_Concerned', pretty_print=pretty_print)
        if self.Interactions_Concerned is not None:
            self.Interactions_Concerned.export(outfile, level, namespace_, name_='Interactions_Concerned', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LsodarOSIType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DS_Concerned is not None:
            showIndent(outfile, level)
            outfile.write('DS_Concerned=model_.vector(\n')
            self.DS_Concerned.exportLiteral(outfile, level, name_='DS_Concerned')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Interactions_Concerned is not None:
            showIndent(outfile, level)
            outfile.write('Interactions_Concerned=model_.vector(\n')
            self.Interactions_Concerned.exportLiteral(outfile, level, name_='Interactions_Concerned')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DS_Concerned':
            obj_ = vector.factory()
            obj_.build(child_)
            self.DS_Concerned = obj_
        elif nodeName_ == 'Interactions_Concerned':
            obj_ = vector.factory()
            obj_.build(child_)
            self.Interactions_Concerned = obj_
# end class LsodarOSIType


class OneStepNSProblems_ListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LCP=None, FrictionContact=None, QP=None, Relay=None):
        if LCP is None:
            self.LCP = []
        else:
            self.LCP = LCP
        if FrictionContact is None:
            self.FrictionContact = []
        else:
            self.FrictionContact = FrictionContact
        if QP is None:
            self.QP = []
        else:
            self.QP = QP
        if Relay is None:
            self.Relay = []
        else:
            self.Relay = Relay
    def factory(*args_, **kwargs_):
        if OneStepNSProblems_ListType.subclass:
            return OneStepNSProblems_ListType.subclass(*args_, **kwargs_)
        else:
            return OneStepNSProblems_ListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LCP(self): return self.LCP
    def set_LCP(self, LCP): self.LCP = LCP
    def add_LCP(self, value): self.LCP.append(value)
    def insert_LCP(self, index, value): self.LCP[index] = value
    def get_FrictionContact(self): return self.FrictionContact
    def set_FrictionContact(self, FrictionContact): self.FrictionContact = FrictionContact
    def add_FrictionContact(self, value): self.FrictionContact.append(value)
    def insert_FrictionContact(self, index, value): self.FrictionContact[index] = value
    def get_QP(self): return self.QP
    def set_QP(self, QP): self.QP = QP
    def add_QP(self, value): self.QP.append(value)
    def insert_QP(self, index, value): self.QP[index] = value
    def get_Relay(self): return self.Relay
    def set_Relay(self, Relay): self.Relay = Relay
    def add_Relay(self, value): self.Relay.append(value)
    def insert_Relay(self, index, value): self.Relay[index] = value
    def hasContent_(self):
        if (
            self.LCP or
            self.FrictionContact or
            self.QP or
            self.Relay
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OneStepNSProblems_ListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OneStepNSProblems_ListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OneStepNSProblems_ListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OneStepNSProblems_ListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OneStepNSProblems_ListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LCP_ in self.LCP:
            LCP_.export(outfile, level, namespace_, name_='LCP', pretty_print=pretty_print)
        for FrictionContact_ in self.FrictionContact:
            FrictionContact_.export(outfile, level, namespace_, name_='FrictionContact', pretty_print=pretty_print)
        for QP_ in self.QP:
            QP_.export(outfile, level, namespace_, name_='QP', pretty_print=pretty_print)
        for Relay_ in self.Relay:
            Relay_.export(outfile, level, namespace_, name_='Relay', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='OneStepNSProblems_ListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('LCP=[\n')
        level += 1
        for LCP_ in self.LCP:
            showIndent(outfile, level)
            outfile.write('model_.LCPType(\n')
            LCP_.exportLiteral(outfile, level, name_='LCPType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FrictionContact=[\n')
        level += 1
        for FrictionContact_ in self.FrictionContact:
            showIndent(outfile, level)
            outfile.write('model_.FrictionContactType(\n')
            FrictionContact_.exportLiteral(outfile, level, name_='FrictionContactType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('QP=[\n')
        level += 1
        for QP_ in self.QP:
            showIndent(outfile, level)
            outfile.write('model_.QPType(\n')
            QP_.exportLiteral(outfile, level, name_='QPType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Relay=[\n')
        level += 1
        for Relay_ in self.Relay:
            showIndent(outfile, level)
            outfile.write('model_.RelayType1(\n')
            Relay_.exportLiteral(outfile, level, name_='RelayType1')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LCP':
            obj_ = LCPType.factory()
            obj_.build(child_)
            self.LCP.append(obj_)
        elif nodeName_ == 'FrictionContact':
            obj_ = FrictionContactType.factory()
            obj_.build(child_)
            self.FrictionContact.append(obj_)
        elif nodeName_ == 'QP':
            obj_ = QPType.factory()
            obj_.build(child_)
            self.QP.append(obj_)
        elif nodeName_ == 'Relay':
            obj_ = RelayType1.factory()
            obj_.build(child_)
            self.Relay.append(obj_)
# end class OneStepNSProblems_ListType


class LCPType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, StorageType=None, Id=None, size=None, Interactions_Concerned=None, NonSmoothSolver=None):
        self.StorageType = _cast(int, StorageType)
        self.Id = _cast(None, Id)
        self.size = size
        self.Interactions_Concerned = Interactions_Concerned
        self.NonSmoothSolver = NonSmoothSolver
    def factory(*args_, **kwargs_):
        if LCPType.subclass:
            return LCPType.subclass(*args_, **kwargs_)
        else:
            return LCPType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def get_Interactions_Concerned(self): return self.Interactions_Concerned
    def set_Interactions_Concerned(self, Interactions_Concerned): self.Interactions_Concerned = Interactions_Concerned
    def get_NonSmoothSolver(self): return self.NonSmoothSolver
    def set_NonSmoothSolver(self, NonSmoothSolver): self.NonSmoothSolver = NonSmoothSolver
    def get_StorageType(self): return self.StorageType
    def set_StorageType(self, StorageType): self.StorageType = StorageType
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def hasContent_(self):
        if (
            self.size is not None or
            self.Interactions_Concerned is not None or
            self.NonSmoothSolver is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LCPType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LCPType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LCPType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LCPType'):
        if self.StorageType is not None and 'StorageType' not in already_processed:
            already_processed.add('StorageType')
            outfile.write(' StorageType="%s"' % self.gds_format_integer(self.StorageType, input_name='StorageType'))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_format_string(quote_attrib(self.Id).encode(ExternalEncoding), input_name='Id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LCPType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.size is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssize>%s</%ssize>%s' % (namespace_, self.gds_format_integer(self.size, input_name='size'), namespace_, eol_))
        if self.Interactions_Concerned is not None:
            self.Interactions_Concerned.export(outfile, level, namespace_, name_='Interactions_Concerned', pretty_print=pretty_print)
        if self.NonSmoothSolver is not None:
            self.NonSmoothSolver.export(outfile, level, namespace_, name_='NonSmoothSolver', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LCPType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.StorageType is not None and 'StorageType' not in already_processed:
            already_processed.add('StorageType')
            showIndent(outfile, level)
            outfile.write('StorageType=%d,\n' % (self.StorageType,))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            showIndent(outfile, level)
            outfile.write('Id="%s",\n' % (self.Id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('size=%d,\n' % self.size)
        if self.Interactions_Concerned is not None:
            showIndent(outfile, level)
            outfile.write('Interactions_Concerned=model_.index_list(\n')
            self.Interactions_Concerned.exportLiteral(outfile, level, name_='Interactions_Concerned')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NonSmoothSolver is not None:
            showIndent(outfile, level)
            outfile.write('NonSmoothSolver=model_.NonSmoothSolver(\n')
            self.NonSmoothSolver.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('StorageType', node)
        if value is not None and 'StorageType' not in already_processed:
            already_processed.add('StorageType')
            try:
                self.StorageType = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.StorageType < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'size':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'size')
            self.size = ival_
        elif nodeName_ == 'Interactions_Concerned':
            obj_ = index_list.factory()
            obj_.build(child_)
            self.Interactions_Concerned = obj_
        elif nodeName_ == 'NonSmoothSolver':
            obj_ = NonSmoothSolver.factory()
            obj_.build(child_)
            self.NonSmoothSolver = obj_
# end class LCPType


class FrictionContactType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, StorageType=None, Type=None, Id=None, size=None, Interactions_Concerned=None, NonSmoothSolver=None):
        self.StorageType = _cast(int, StorageType)
        self.Type = _cast(int, Type)
        self.Id = _cast(None, Id)
        self.size = size
        self.Interactions_Concerned = Interactions_Concerned
        self.NonSmoothSolver = NonSmoothSolver
    def factory(*args_, **kwargs_):
        if FrictionContactType.subclass:
            return FrictionContactType.subclass(*args_, **kwargs_)
        else:
            return FrictionContactType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def get_Interactions_Concerned(self): return self.Interactions_Concerned
    def set_Interactions_Concerned(self, Interactions_Concerned): self.Interactions_Concerned = Interactions_Concerned
    def get_NonSmoothSolver(self): return self.NonSmoothSolver
    def set_NonSmoothSolver(self, NonSmoothSolver): self.NonSmoothSolver = NonSmoothSolver
    def get_StorageType(self): return self.StorageType
    def set_StorageType(self, StorageType): self.StorageType = StorageType
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def hasContent_(self):
        if (
            self.size is not None or
            self.Interactions_Concerned is not None or
            self.NonSmoothSolver is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FrictionContactType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FrictionContactType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FrictionContactType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FrictionContactType'):
        if self.StorageType is not None and 'StorageType' not in already_processed:
            already_processed.add('StorageType')
            outfile.write(' StorageType="%s"' % self.gds_format_integer(self.StorageType, input_name='StorageType'))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type="%s"' % self.gds_format_integer(self.Type, input_name='Type'))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_format_string(quote_attrib(self.Id).encode(ExternalEncoding), input_name='Id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FrictionContactType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.size is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssize>%s</%ssize>%s' % (namespace_, self.gds_format_integer(self.size, input_name='size'), namespace_, eol_))
        if self.Interactions_Concerned is not None:
            self.Interactions_Concerned.export(outfile, level, namespace_, name_='Interactions_Concerned', pretty_print=pretty_print)
        if self.NonSmoothSolver is not None:
            self.NonSmoothSolver.export(outfile, level, namespace_, name_='NonSmoothSolver', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FrictionContactType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.StorageType is not None and 'StorageType' not in already_processed:
            already_processed.add('StorageType')
            showIndent(outfile, level)
            outfile.write('StorageType=%d,\n' % (self.StorageType,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            showIndent(outfile, level)
            outfile.write('Type=%d,\n' % (self.Type,))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            showIndent(outfile, level)
            outfile.write('Id="%s",\n' % (self.Id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('size=%d,\n' % self.size)
        if self.Interactions_Concerned is not None:
            showIndent(outfile, level)
            outfile.write('Interactions_Concerned=model_.index_list(\n')
            self.Interactions_Concerned.exportLiteral(outfile, level, name_='Interactions_Concerned')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NonSmoothSolver is not None:
            showIndent(outfile, level)
            outfile.write('NonSmoothSolver=model_.NonSmoothSolver(\n')
            self.NonSmoothSolver.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('StorageType', node)
        if value is not None and 'StorageType' not in already_processed:
            already_processed.add('StorageType')
            try:
                self.StorageType = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.StorageType < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            try:
                self.Type = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.Type <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'size':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'size')
            self.size = ival_
        elif nodeName_ == 'Interactions_Concerned':
            obj_ = index_list.factory()
            obj_.build(child_)
            self.Interactions_Concerned = obj_
        elif nodeName_ == 'NonSmoothSolver':
            obj_ = NonSmoothSolver.factory()
            obj_.build(child_)
            self.NonSmoothSolver = obj_
# end class FrictionContactType


class QPType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, StorageType=None, Id=None, size=None, Q=None, p=None, Interactions_Concerned=None, NonSmoothSolver=None):
        self.StorageType = _cast(int, StorageType)
        self.Id = _cast(None, Id)
        self.size = size
        self.Q = Q
        self.p = p
        self.Interactions_Concerned = Interactions_Concerned
        self.NonSmoothSolver = NonSmoothSolver
    def factory(*args_, **kwargs_):
        if QPType.subclass:
            return QPType.subclass(*args_, **kwargs_)
        else:
            return QPType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def get_Q(self): return self.Q
    def set_Q(self, Q): self.Q = Q
    def get_p(self): return self.p
    def set_p(self, p): self.p = p
    def get_Interactions_Concerned(self): return self.Interactions_Concerned
    def set_Interactions_Concerned(self, Interactions_Concerned): self.Interactions_Concerned = Interactions_Concerned
    def get_NonSmoothSolver(self): return self.NonSmoothSolver
    def set_NonSmoothSolver(self, NonSmoothSolver): self.NonSmoothSolver = NonSmoothSolver
    def get_StorageType(self): return self.StorageType
    def set_StorageType(self, StorageType): self.StorageType = StorageType
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def hasContent_(self):
        if (
            self.size is not None or
            self.Q is not None or
            self.p is not None or
            self.Interactions_Concerned is not None or
            self.NonSmoothSolver is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QPType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QPType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QPType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QPType'):
        if self.StorageType is not None and 'StorageType' not in already_processed:
            already_processed.add('StorageType')
            outfile.write(' StorageType="%s"' % self.gds_format_integer(self.StorageType, input_name='StorageType'))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_format_string(quote_attrib(self.Id).encode(ExternalEncoding), input_name='Id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QPType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.size is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssize>%s</%ssize>%s' % (namespace_, self.gds_format_integer(self.size, input_name='size'), namespace_, eol_))
        if self.Q is not None:
            self.Q.export(outfile, level, namespace_, name_='Q', pretty_print=pretty_print)
        if self.p is not None:
            self.p.export(outfile, level, namespace_, name_='p', pretty_print=pretty_print)
        if self.Interactions_Concerned is not None:
            self.Interactions_Concerned.export(outfile, level, namespace_, name_='Interactions_Concerned', pretty_print=pretty_print)
        if self.NonSmoothSolver is not None:
            self.NonSmoothSolver.export(outfile, level, namespace_, name_='NonSmoothSolver', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QPType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.StorageType is not None and 'StorageType' not in already_processed:
            already_processed.add('StorageType')
            showIndent(outfile, level)
            outfile.write('StorageType=%d,\n' % (self.StorageType,))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            showIndent(outfile, level)
            outfile.write('Id="%s",\n' % (self.Id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('size=%d,\n' % self.size)
        if self.Q is not None:
            showIndent(outfile, level)
            outfile.write('Q=model_.matrix(\n')
            self.Q.exportLiteral(outfile, level, name_='Q')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.p is not None:
            showIndent(outfile, level)
            outfile.write('p=model_.vector(\n')
            self.p.exportLiteral(outfile, level, name_='p')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Interactions_Concerned is not None:
            showIndent(outfile, level)
            outfile.write('Interactions_Concerned=model_.index_list(\n')
            self.Interactions_Concerned.exportLiteral(outfile, level, name_='Interactions_Concerned')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NonSmoothSolver is not None:
            showIndent(outfile, level)
            outfile.write('NonSmoothSolver=model_.NonSmoothSolver(\n')
            self.NonSmoothSolver.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('StorageType', node)
        if value is not None and 'StorageType' not in already_processed:
            already_processed.add('StorageType')
            try:
                self.StorageType = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.StorageType < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'size':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'size')
            self.size = ival_
        elif nodeName_ == 'Q':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.Q = obj_
        elif nodeName_ == 'p':
            obj_ = vector.factory()
            obj_.build(child_)
            self.p = obj_
        elif nodeName_ == 'Interactions_Concerned':
            obj_ = index_list.factory()
            obj_.build(child_)
            self.Interactions_Concerned = obj_
        elif nodeName_ == 'NonSmoothSolver':
            obj_ = NonSmoothSolver.factory()
            obj_.build(child_)
            self.NonSmoothSolver = obj_
# end class QPType


class RelayType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, StorageType=None, Id=None, size=None, M=None, q=None, Interactions_Concerned=None, NonSmoothSolver=None):
        self.StorageType = _cast(int, StorageType)
        self.Id = _cast(None, Id)
        self.size = size
        self.M = M
        self.q = q
        self.Interactions_Concerned = Interactions_Concerned
        self.NonSmoothSolver = NonSmoothSolver
    def factory(*args_, **kwargs_):
        if RelayType1.subclass:
            return RelayType1.subclass(*args_, **kwargs_)
        else:
            return RelayType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def get_M(self): return self.M
    def set_M(self, M): self.M = M
    def get_q(self): return self.q
    def set_q(self, q): self.q = q
    def get_Interactions_Concerned(self): return self.Interactions_Concerned
    def set_Interactions_Concerned(self, Interactions_Concerned): self.Interactions_Concerned = Interactions_Concerned
    def get_NonSmoothSolver(self): return self.NonSmoothSolver
    def set_NonSmoothSolver(self, NonSmoothSolver): self.NonSmoothSolver = NonSmoothSolver
    def get_StorageType(self): return self.StorageType
    def set_StorageType(self, StorageType): self.StorageType = StorageType
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def hasContent_(self):
        if (
            self.size is not None or
            self.M is not None or
            self.q is not None or
            self.Interactions_Concerned is not None or
            self.NonSmoothSolver is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RelayType1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelayType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RelayType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RelayType1'):
        if self.StorageType is not None and 'StorageType' not in already_processed:
            already_processed.add('StorageType')
            outfile.write(' StorageType="%s"' % self.gds_format_integer(self.StorageType, input_name='StorageType'))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_format_string(quote_attrib(self.Id).encode(ExternalEncoding), input_name='Id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RelayType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.size is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssize>%s</%ssize>%s' % (namespace_, self.gds_format_integer(self.size, input_name='size'), namespace_, eol_))
        if self.M is not None:
            self.M.export(outfile, level, namespace_, name_='M', pretty_print=pretty_print)
        if self.q is not None:
            self.q.export(outfile, level, namespace_, name_='q', pretty_print=pretty_print)
        if self.Interactions_Concerned is not None:
            self.Interactions_Concerned.export(outfile, level, namespace_, name_='Interactions_Concerned', pretty_print=pretty_print)
        if self.NonSmoothSolver is not None:
            self.NonSmoothSolver.export(outfile, level, namespace_, name_='NonSmoothSolver', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RelayType1'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.StorageType is not None and 'StorageType' not in already_processed:
            already_processed.add('StorageType')
            showIndent(outfile, level)
            outfile.write('StorageType=%d,\n' % (self.StorageType,))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            showIndent(outfile, level)
            outfile.write('Id="%s",\n' % (self.Id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('size=%d,\n' % self.size)
        if self.M is not None:
            showIndent(outfile, level)
            outfile.write('M=model_.matrix(\n')
            self.M.exportLiteral(outfile, level, name_='M')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.q is not None:
            showIndent(outfile, level)
            outfile.write('q=model_.vector(\n')
            self.q.exportLiteral(outfile, level, name_='q')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Interactions_Concerned is not None:
            showIndent(outfile, level)
            outfile.write('Interactions_Concerned=model_.index_list(\n')
            self.Interactions_Concerned.exportLiteral(outfile, level, name_='Interactions_Concerned')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NonSmoothSolver is not None:
            showIndent(outfile, level)
            outfile.write('NonSmoothSolver=model_.NonSmoothSolver(\n')
            self.NonSmoothSolver.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('StorageType', node)
        if value is not None and 'StorageType' not in already_processed:
            already_processed.add('StorageType')
            try:
                self.StorageType = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.StorageType < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'size':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'size')
            self.size = ival_
        elif nodeName_ == 'M':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.M = obj_
        elif nodeName_ == 'q':
            obj_ = vector.factory()
            obj_.build(child_)
            self.q = obj_
        elif nodeName_ == 'Interactions_Concerned':
            obj_ = index_list.factory()
            obj_.build(child_)
            self.Interactions_Concerned = obj_
        elif nodeName_ == 'NonSmoothSolver':
            obj_ = NonSmoothSolver.factory()
            obj_.build(child_)
            self.NonSmoothSolver = obj_
# end class RelayType1


GDSClassesMapping = {
    'jacobianH': listOfMatrices,
    'LCP': LCPType,
    'QP': QPType,
    'indexList': vector,
    'MoreauJeanOSI': MoreauJeanOSIType,
    'Velocity0': vector,
    'Memory': vector,
    'iparam': vector,
    'LsodarOSI': LsodarOSIType,
    'NNL': vector,
    'Interaction': InteractionType,
    'LagrangianLinearTIDS': LagrangianLinearTIDSType,
    'FirstOrderRelation': FirstOrderRelationType,
    'Theta': emptyType,
    'NSDS': NSDSType,
    'VelocityMemory': memory,
    'NewtonImpactLaw': NewtonImpactLawType,
    'D': matrix,
    'FirstOrderLinearDS': FirstOrderLinearDSType,
    'q0': vector,
    'FirstOrderLinearTIDS': FirstOrderLinearTIDSType,
    'NewtonImpactFrictionLaw': NewtonImpactFrictionLawType,
    'Linear': LinearType,
    'FirstOrderNonLinearDS': FirstOrderNonLinearDSType,
    'Velocity': vector,
    'F': matrix,
    'jacobianG': listOfMatrices,
    'FirstOrderLinearRelation': FirstOrderLinearRelationType,
    'Omega0': matrix,
    'FirstOrderLinearTimeInvariantRelation': FirstOrderLinearTimeInvariantRelationType,
    'Q': matrix,
    'tk': vector,
    'DS_Definition': DS_DefinitionType,
    'OmegaT': matrix,
    'OneStepIntegrator_Definition': OneStepIntegrator_DefinitionType,
    'Omega': vector,
    'DS_Concerned': vector,
    'A': matrix,
    'LagrangianLinearRelation': LagrangianLinearRelationType,
    'C': matrix,
    'Jacobianfx': matrix,
    'FrictionContact': FrictionContactType,
    'Interaction_Content': Interaction_ContentType,
    'Interaction_Definition': Interaction_DefinitionType,
    'FExt': vector,
    'H': matrix,
    'K': matrix,
    'M': matrix,
    'FInt': vector,
    'Simulation': SimulationType,
    'JacobianQFInt': matrix,
    'Periodic': PeriodicType,
    'Mass': matrix,
    'NLinear': NLinearType,
    'Time': ModelTime,
    'dparam': vector,
    'x0': vector,
    'DS_LMGC90': DS_LMGC90Type,
    'OneStepNSProblems_List': OneStepNSProblems_ListType,
    'LagrangianDS': LagrangianDSType,
    'JacobianQNNL': matrix,
    'xMemory': memory,
    'b': vector,
    'LagrangianRelation': LagrangianRelationType,
    'Relay': RelayType1,
    'g': pluginDef,
    'f': vector,
    'h': pluginDef,
    'TimeDiscretisation': TimeDiscretisationType,
    'q': vector,
    'p': vector,
    'ComplementarityCondition': ComplementarityConditionType,
    'qMemory': memory,
    'e': vector,
    'OneStepIntegrator_LMGC90': OneStepIntegrator_LMGC90Type,
    'Interactions_Concerned': index_list,
    'y': vector,
    'x': vector,
    'B': matrix,
    'JacobianVelocityFInt': matrix,
    'JacobianVelocityNNL': matrix,
    'lambda': vector,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'emptyType'
        rootClass = emptyType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'emptyType'
        rootClass = emptyType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from io import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    roots = get_root_tag(rootNode)
    rootClass = roots[1]
    if rootClass is None:
        rootClass = emptyType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_="emptyType",
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'emptyType'
        rootClass = emptyType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from SiconosXMLParser import *\n\n')
        sys.stdout.write('import SiconosXMLParser as model_\n\n')
        sys.stdout.write('rootObj = model_.rootTag(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "BoundaryCondition",
    "ComplementarityConditionType",
    "DS_DefinitionType",
    "DS_LMGC90Type",
    "FirstOrderLinearDSType",
    "FirstOrderLinearRelationType",
    "FirstOrderLinearTIDSType",
    "FirstOrderLinearTimeInvariantRelationType",
    "FirstOrderNonLinearDSType",
    "FirstOrderRelationType",
    "FrictionContactType",
    "InteractionType",
    "Interaction_ContentType",
    "Interaction_DefinitionType",
    "LCPType",
    "LagrangianDSType",
    "LagrangianLinearRelationType",
    "LagrangianLinearTIDSType",
    "LagrangianRelationType",
    "LinearType",
    "LsodarOSIType",
    "ModelTime",
    "MoreauJeanOSIType",
    "NLinearType",
    "NSDSType",
    "NewtonImpactFrictionLawType",
    "NewtonImpactLawType",
    "NonSmoothSolver",
    "OneStepIntegrator_DefinitionType",
    "OneStepIntegrator_LMGC90Type",
    "OneStepNSProblems_ListType",
    "PeriodicType",
    "QPType",
    "RelayType",
    "RelayType1",
    "SiconosModel",
    "SimulationType",
    "TimeDiscretisationType",
    "emptyType",
    "index_list",
    "listOfMatrices",
    "matrix",
    "matrixData",
    "matrixFile",
    "matrixPlugin",
    "memory",
    "pluginDef",
    "vector"
]
