# -*- python -*-

import os
import time
from pyplusplus import module_builder
from pyplusplus import messages
from pyplusplus.module_builder import call_policies
from pygccxml import declarations
from doxygen import doxygen_doc_extractor

import logging
from pygccxml import utils
logger = utils.loggers.cxx_parser
logger.setLevel(logging.DEBUG)


Utils = [
    # Siconos Algebra
    'SiconosVector', 'SiconosMatrix',
    'SimpleVector', 'SimpleMatrix', 'BlockVector', 
    'BlockMatrix', 'ioMatrix', 'ioVector', 'ioObject', 
    
    # Siconos Exception
    'RuntimeException', 'SiconosException', 
    'SiconosMatrixException', 'SiconosMemoryException', 
    'SiconosSharedLibraryException', 
    'SiconosVectorException', 'XMLException',
    
    # Siconos Memory
    'SiconosMemory',
    
    # Siconos shared library
    'SiconosSharedLibrary'
    ]


Model = [ 'Model' ]

ModelingTools = [ 'ComplementarityConditionNSL', 'DynamicalSystem', 
                  'FirstOrderLinearDS', 'FirstOrderLinearR', 
                  'FirstOrderLinearTIDS', 'FirstOrderLinearTIR',
                  'FirstOrderNonLinearDS', 
                  'Interaction',
                  'LagrangianCompliantR',
                  'LagrangianDS', 
                  'LagrangianLinearTIDS',
                  'LagrangianLinearTIR',
                  'LagrangianRheonomousR',
                  'LagrangianScleronomousR',
                  'MixedComplementarityConditionNSL',
                  'NewtonImpactFrictionNSL',
                  'NewtonImpactNSL',
                  'NonSmoothDynamicalSystem', 
                  'NonSmoothLaw',
                  'Relation',
                  'RelayNSL'
                   
                  ]

SimulationTools = [ 'Event', 'EventDriven', 'FrictionContact', 'LCP', 'LinearOSNS', 'Lsodar',
                    'MLCP', 'Moreau', 'NonSmoothEvent', 'NonSmoothSolver', 
                    'OneStepIntegrator', 'OneStepNSProblem', 'QP',
                    'Relay' , 'Simulation', 'BlockCSRMatrix', 'TimeDiscretisation', 
                    'TimeDiscretisation', 'TimeDiscretisationEvent', 'TimeStepping', 'Topology',
                    'UnitaryRelation' ]

siconos_classes = Utils + Model + ModelingTools + SimulationTools

siconos_declarations = [ 'Plugged_Vector_FTime', 'Plugged_Matrix_FTime', 'InteractionsSet', 'DynamicalSystemsSet' ]

siconos_templates = [ ]

siconos_headers = [ 'SiconosKernelExport.hpp' ]
#map(lambda name: name + '.h', siconos_classes)

 
def generate_code():  
    # py++ main class

    print 'Generating boost python code ...'

    mb = module_builder.module_builder_t( siconos_headers, 
                                          include_paths=['@SiconosNumerics_INCLUDE_DIRS@', 
                                                         '@SiconosKernel_INCLUDE_DIRS@', 
                                                         '@ATLAS_INCLUDE_DIR@', 
                                                         '@LIBXML2_INCLUDE_DIR@' ],
                                          working_directory = r".", 
                                          indexing_suite_version = 2 )


    # Global settings
    
    #Set max number of arguments
    mb.BOOST_PYTHON_MAX_ARITY = 25                       
    


    mb.classes().always_expose_using_scope = True

# always_expose_using_scope documentation:

#boolean, configures how `Py++` should generate code for class.
#Py can generate code using IDL like syntax:
#
#    class_< ... >( ... )
#        .def( ... );
#
#Or it can generate code using more complex form:
#
#    typedef bp::class_< my_class > my_class_exposer_t;
#    my_class_exposer_t my_class_exposer = my_class_exposer_t( "my_class" );
#    boost::python::scope my_class_scope( my_class_exposer );
#    my_class_exposer.def( ... );
#
#Also, the second way is much longer, it solves few problems:
#
#    - you can not expose enums and internal classes defined within the class using first method
#    - you will get much better compilation errors
#    - the code looks like regular C++ code after all :-)
#
#By default, this property is set to False. Also, `Py++` knows pretty well
#when it have to ignore this property and generate right code 

    mb.constructors().allow_implicit_conversion = True         
    
    messages.disable( 
        #           Warnings 1020 - 1031 are all about why Py++ generates wrapper for class X
        messages.W1020
        , messages.W1021
        , messages.W1022
        , messages.W1023
        , messages.W1024
        , messages.W1025
        , messages.W1026
        , messages.W1027
        , messages.W1028
        , messages.W1029
        , messages.W1030
        , messages.W1031
        #         , messages.W1035
        #         , messages.W1040 
        #         , messages.W1038        
        #         , messages.W1041
        , messages.W1036 # pointer to Python immutable member
        , messages.W1033 # unnamed variables
        , messages.W1018 # expose unnamed classes
        , messages.W1049 # returns reference to local variable
        , messages.W1014 # unsupported '=' operator
        )
    


    # Selective inclusion
#    mb.decls( recursive=True ).exclude()

    
    for class_name in siconos_classes:
        print "Including class : " + class_name
        mb.global_ns.class_(class_name).include()


    for decl in siconos_declarations:
        print "Including declaration : " + decl
        mb.global_ns.decls(decl).include()

    for enum_ in mb.enumerations():
        print "Including enumeration : " + enum_.name
        enum_.include()

    for template_name in siconos_templates:
        templates = mb.classes( lambda cls: cls.name.find( template_name ) >= 0 )
        for t in templates:
            if len(t.name) < 100: 
                print "Including template : " + t.name
                t.include()

    dsets = mb.classes( lambda cls: cls.name.startswith( 'SiconosSet' ) )
    for d in dsets:
        print "Including :" + d.name
        d.include()

    typedefs = mb.global_ns.typedefs( lambda td: td.name == 'CheckInsertT' 
                                      or td.name == 'ConstTIterator' or td.name == 'TIterator' ) 
    for td in typedefs:
        decls = mb.decls( lambda decl: decl.alias == td.name )
        for d in decls:
            print "d:" + d.name + ":" + d.decl_string
            mb.print_declarations( d )
            d.ignore = False
            d.include()
            for cl in mb.global_ns.classes( d.decl_string , allow_empty = True):
                print "c:" + cl.name
                c.include()




#    for c in mb.classes ( lambda cl: cl.alias == 'DynamicalSystemsSet' ):
#        c.ignore = False
#        c.include()
#        c.mem_funs('insert').call_policies = call_policies.return_opaque_pointer()


#    pair = mb.classes( lambda cls: cls.name.find( 'pair<boost::shared_ptr<DynamicalSystem, double' ) >= 0 )
#    for p in pair:
#        print "PAIR:" + p.name
#        mb.print_declarations( p )
#        p.include()



    # functions and operators exclusions 
    for cl in mb.global_ns.classes( recursive=True ):
        cl.mem_funs('getArray', allow_empty=True).exclude()
        cl.mem_funs('begin', allow_empty=True).exclude()
        cl.mem_funs('end', allow_empty=True).exclude()
        cl.mem_funs('dynamicalSystemsBegin', allow_empty=True).exclude()
        cl.mem_funs('dynamicalSystemsEnd', allow_empty=True).exclude()
        cl.mem_funs('getSort', allow_empty=True).exclude()
        cl.operators('operator()', allow_empty=True).exclude()

    mb.decls( lambda decl:
                  decl.name.find('traits') >= 0 or
              decl.name.find('sp_enable_if_auto_ptr') >=0 or
              decl.name.find('__') >=0 or
              decl.name.find('extract_value') >=0 or
               decl.name.startswith('BaseClass') or
              decl.name.startswith('MapOfMapOfUnitaryMatrices') ).exclude()
    
     # set default call policy for reference and pointer
    funs = mb.calldefs()

    funs.create_with_signature = True
    for fun in funs:
        if fun.call_policies:
            continue
        
        # References and pointers
        if (not fun.call_policies) and (declarations.is_reference(fun.return_type) or 
                                             (declarations.is_pointer (fun.return_type)) ):
            print 'Setting call policy for %s to reference' % fun.name 
            fun.call_policies = call_policies.return_value_policy(call_policies.reference_existing_object )
            
            
    #Creating code creator. After this step you should not
    #modify/customize declarations.
    mb.build_code_creator( module_name='Siconos', doc_extractor=doxygen_doc_extractor() )
            
    mb.code_creator.license = """/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */
 """
            
#Writing code to files.
    mb.split_module( os.path.join( os.path.abspath('.'), 'Siconos' ) )
                
if __name__ == '__main__':
    start_time = time.clock()
    generate_code()
    print 'Boost python generation done (%f seconds)' % (  ( time.clock() - start_time ) )
