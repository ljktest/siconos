"""
Tools used during configuration and build process of the documentation
(mostly "bridges" between doxygen, breathe and sphinx)

This file is to be copied into CMAKE_BINARY_DIR/share using configure_file
"""

""" Siconos is a program dedicated to modeling, simulation and control
 of non smooth dynamical systems.

 Copyright 2018 INRIA.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
"""

import glob
import os
import subprocess
import buildtools as bt

try:
    from doxy2swig import Doxy2SWIG
except:
    pass #
import parse_doxygen as pxml

try:
    import lxml.etree as ET
except ImportError:
    import xml.etree.ElementTree as ET


def parse_doxygen_config(filename):
    """Read doxygen config into a python dictionnary
    
    Parameters
    ----------
    filename : string
       full path to doxygen file
    
    Returns a python dictionnary
    """
    result = {}
    with open(filename) as ff:
        # remove comment lines
        conf = [n.strip() for n in ff.readlines() if (not n.startswith('#') and not n.startswith('\n'))]
        for d in conf:
            if d.count('=') > 0:
                res = d.split('=')
                result[res[0].rsplit()[0]] = res[1]
                backup = res.copy()
            else:
                result[backup[0].rsplit()[0]] += d
    return result
    
def get_xml_files(header_name, xml_path, case_sense_names=True):
    """Return all xml files generated by doxygen from a given header file.
    and found in a given path.

    Parameters
    ----------
    header_name : string
        header file.
    xml_path : string
        absolute path to xml files.
    case_sense_names : bool
        false if xml output files names are lower case only

    Returns a list of xml files.
    
    Notes
    -----
 
    * This function takes into account the value of CASE_SENSE_NAMES parameter
    in doxygen config.
    * It looks for '*classNAME.xml', '*structNAME.xml' and 'NAME_8h*.xml'
    name being the input header name (without ext).

    """
    # Get filename without extension
    fnwe = os.path.basename(header_name).split('.')[0]
    # Replace _ with __ in filename
    fnwe = fnwe.replace('_', '__')
    if not case_sense_names:
        fnwe = replace_uppercase_letters(fnwe)
    # Look for 'class' files
    classfiles = glob.glob(os.path.join(xml_path, '*class' + fnwe + '*.xml'))
    # Look for 'struct' files
    structfiles = glob.glob(os.path.join(xml_path, '*struct' + fnwe + '*.xml'))
    # Look for '8h' (?) files
    files8h = glob.glob(os.path.join(xml_path, fnwe + '_8h*.xml'))
    allfiles = classfiles + structfiles + files8h
    return allfiles



def xml2swig(header_name, xml_path, swig_path, case_sense_names):
    """For a given header file, create swig (.i) file using 
    xml outputs from doxygen (Driver : Doxy2SWIG)

    Parameters
    ----------
    header_name : string
        Name of the header file (h or hpp)
    xml_path : string
        absolute path to xml files.
    swig_path : string
        Absolute path to swig outputs
    case_sense_names : bool
        false if xml output files names are lower case only
   
     Notes
     -----
     * This function takes into account the value of CASE_SENSE_NAMES parameter
     in doxygen config.
     * .i file will be named as the xml input file, with .i as ext.

    """
    allfiles = get_xml_files(header_name, xml_path, case_sense_names)
    
    if not os.path.exists(swig_path):
        os.makedirs(swig_path)
    for f in allfiles:
        # set output filename == xml file without extension + .i
        outputname = os.path.basename(f).split('.')[0] + '.i'
        outputname = os.path.join(swig_path, outputname)
        p = Doxy2SWIG(f)
        # with_function_signature = options.f,
        # with_type_info = options.t,
        # with_constructor_list = options.c,
        # with_attribute_list = options.a,
        # with_overloaded_functions = options.o,
        # textwidth = options.w,
        # quiet = options.q)
        p.generate()
        p.write(outputname)
        msg = "Docstrings generation for "
        msg += header_name + " from " + f
        #print(msg)


def xml2swig_v2(header_name, xml_path, swig_path, case_sense_names):
    """For a given header file, create swig (.i) file using 
    xml outputs from doxygen. (Driver = parse_doxygen)

    Parameters
    ----------
    header_name : string
        Name of the header file (h or hpp)
    xml_path : string
        absolute path to xml files.
    swig_path : string
        Absolute path to swig outputs
    case_sense_names : bool
        false if xml output files names are lower case only
   
     Notes
     -----
     * This function takes into account the value of CASE_SENSE_NAMES parameter
     in doxygen config.
     * .i file will be named as the xml input file, with .i as ext.

    """
    allfiles = get_xml_files(header_name, xml_path, case_sense_names)
    
    if not os.path.exists(swig_path):
        os.makedirs(swig_path)
    for f in allfiles:
        # set output filename == xml file without extension + .i
        outputname = os.path.basename(f).split('.')[0] + '.i'
        outputname = os.path.join(swig_path, outputname)

        ns = pxml.read_doxygen_xml_files_no_ns(xml_path, f)
        members = list(ns['ALL'].members.values())
        for m in members:
            print(m.name)
        # with open('apitest.rst', 'wt') as out:
        #     for member in members:
        #         out.write(member.to_rst())
        #         out.write('\n')
        #     out.write('\n')

        with open(outputname, 'wt') as out:
            #out.write('// SWIG docstrings generated by doxygen and parse_doxygen.py\n\n')
            for member in members:
                 out.write(member.to_swig())
                 out.write('\n')
            out.write('\n')

        #print("process OOKOKO ", f, members)
        msg = "Docstrings generation for "
        msg += header_name + " from " + f
        #print(msg)
        

def replace_uppercase_letters(filename):
    """Replace uppercase letters in a string
    with _lowercase (following doxygen way)
    
    e.g. : TimeStepping --> _time_stepping

    This is useful to postprocess filenames from xml-doxygen outputs
    and feed them to doxy2swig, even when CASE_SENSE_NAMES = NO
    in doxygen config.

    Usage:

    result = replace_uppercase_letters(input)
      
    """
    r = []
    for c in filename:
        # l being: last character was not uppercase
        newc = c
        if c.isupper():
            newc ='_' + c.lower()
        r.append(newc)
    return ''.join(r)


def filter_doxygen_warnings_files(warnings_path, outputfile):
    """Post process outputs from doxygen warnings : 
     * remove all empty files
     * cat all warnings files into one

     Parameters
     ----------
     warnings_path : string
         full path to warnings files
     outputfile : string
         name of resulting file (concat.). Saved in warnings_path
    """
    
    warnfiles = glob.glob(os.path.join(warnings_path, '*.warnings'))
    real_warnings = []
    for f in warnfiles:
        if os.stat(f).st_size == 0:
            os.remove(f)
        else:
            real_warnings.append(f)
    outputfile = os.path.join(warnings_path, outputfile)
    with open(outputfile, 'w') as outfile:
        for fname in real_warnings:
            with open(fname) as infile:
                for line in infile:
                    outfile.write(line)
            
    
def parse_doxygen_wrapper(xml_directory, rst_directory):

    # Look for 'namespaces
    namespacefiles = glob.glob(os.path.join(xml_directory, 'namespace*.xml'))
    xmlnamespaces = []
    for f in namespacefiles:
        name = os.path.basename(f).split('.')[0]
        name = name.split('namespace')[1]
        xmlnamespaces.append(name)

    all_rst_files = []
    all_swig_files = []
    for namespace in xmlnamespaces:
        namespaces = pdox.read_doxygen_xml_files(xml_directory, [namespace])
        # Get sorted list of members
        members = list(namespaces[namespace].members.values())
        members.sort(key=lambda m: m.name)
    
        # Make Sphinx documentation
        filename = namespace + '_api.rst'
        with open(filename, 'wt') as out:
            for member in members:
                out.write(member.to_rst())
                out.write('\n')
            out.write('\n')
            all_rst_files.append(filename)
            
        # Make SWIG interface file
        filename = namespace + '_docstrings.i' 
        with open(filename, 'wt') as out:
            out.write('// SWIG docstrings generated by doxygen and parse_doxygen.py\n\n')
            for member in members:
                out.write(member.to_swig())
                out.write('\n')
            out.write('\n')
            all_swig_files.append(filename)
    
        for tag in pdox.NOT_IMPLEMENTED_ELEMENTS:
            print('WARNING: doxygen XML tag %s is not supported by the parser' % tag)
            
        docstringsfile = 'generared_docstrings.i'
        sphinxfile = os.path.join(rst_directory, 'generated_api.rst')
        with open(sphinxfile, 'w') as outfile:
            header ='doxy to rst\n-----------\n\n'
            outfile.write(header)

            for fname in all_rst_files:
                namesp = fname.split('_api.rst')[0]
                line= namesp + '\n-----------\n\n'
                outfile.write(line)
                
                with open(fname) as infile:
                    for line in infile:
                        outfile.write(line)
        with open(docstringsfile, 'w') as outfile:
            for fname in all_swig_files:
                with open(fname) as infile:
                    for line in infile:
                        outfile.write(line)
  


def build_docstrings(headers, component_name, doxygen_config_filename, swig_path):
    """Create docstrings (doxy2swig) in swig files from xml (doxygen) generated
    from headers.

    Parameters
    ----------

    headers : list (cmake like)
         headers files to parse
    component_name : string
         component (numerics, kernel, ...) of interest
    doxygen_config_filename : string
         name (full path) of the doxygen configuration file
    swig_path : string
         path to swig outputs

    Note
    ----
    * all swig files will be genereted into swig_path/tmp_component_name directory
    and concatenated into component_name-docstrings.i that will be the file really
    used by swig.
    """
    doxyconf = parse_doxygen_config(doxygen_config_filename)
    case_sense_names = doxyconf['CASE_SENSE_NAMES'].find('YES') > -1 
    xml_path = os.path.join(doxyconf['OUTPUT_DIRECTORY'].lstrip(), doxyconf['XML_OUTPUT'].lstrip())
    tmp_path = os.path.join(swig_path, 'tmp_' + component_name)
    headers = bt.parse_cmake_list(headers)
    for hfile in headers:
        xml2swig(hfile, xml_path, tmp_path, case_sense_names)
        
    outputfile = os.path.join(swig_path, component_name + '-docstrings.i')
    swigfiles = glob.glob(os.path.join(tmp_path, '*.i'))
    with open(outputfile, 'w') as outfile:
        for fname in swigfiles:
            with open(fname) as infile:
                for line in infile:
                    outfile.write(line)
    msg = 'Generates file ' # + outputfile + ' for doctrings in swig.'
    print(msg)


def create_breathe_files(headers, srcdir, component_name, sphinx_directory, doxygen_config_filename):
    """Create rst files for sphinx from xml (doxygen) outputs generated from headers.

    Parameters
    ----------

    headers : list (cmake like)
         headers files to parse
    srcdir : string
        absolute path to c/c++ sources (CMAKE_SOURCE_DIR)
    component_name : string
         component (numerics, kernel, ...) of interest
    sphinx_directory : string
        directory where rst files will be written
    doxygen_config_filename : string
         name (full path) of the doxygen configuration file

    Notes:
    * for each header, rst files (class, struct, file and source codes) will be generated
    * three other 'main' rst files will be produced :
       * breathe_api.rst, with the toctree for all classes and structs
       * files_list.rst, with the toctree for all files documentation
       * sources_list.rst with the toctree for all program listings

    """
    headers = bt.parse_cmake_list(headers)
    rst_files = []
    rst_programs = []
    doxyconf = parse_doxygen_config(doxygen_config_filename)
    xmlconf = {}
    sphinx_directory = os.path.join(sphinx_directory, component_name)
    if not os.path.exists(sphinx_directory):
        os.makedirs(sphinx_directory)
    
    xmlconf['CASE_SENSE_NAMES'] = doxyconf['CASE_SENSE_NAMES'].find('YES') > -1 
    xmlconf['XML_OUTPUT'] = os.path.join(doxyconf['OUTPUT_DIRECTORY'].lstrip(), doxyconf['XML_OUTPUT'].lstrip())
    for hfile in headers:
        xml2rst(hfile, srcdir, component_name, sphinx_directory, xmlconf)

    class_and_struct_files = glob.glob(os.path.join(sphinx_directory, 'class*.rst'))
    class_and_struct_files += glob.glob(os.path.join(sphinx_directory, 'struct*.rst'))
    class_and_struct_files.sort()
    pgm_files = glob.glob(os.path.join(sphinx_directory, 'pgm_*.rst'))
    pgm_files.sort()
    rst_files = glob.glob(os.path.join(sphinx_directory, 'file_*.rst'))
    rst_files.sort()
    outputname = os.path.join(sphinx_directory, 'breathe_api.rst')
    title = component_name.title() + ' classes and structs (C/C++)'
    title += '\n' + len(title) * '=' + '\n\n'
    print("Write ", outputname)
    with open(outputname, 'wt') as out:
        out.write(title)
        out.write('.. toctree::\n\t:maxdepth: 4\n\n')
        for f in class_and_struct_files:
            name = os.path.basename(f).split('.')[0]
            out.write('\t' + name + '\n')


    outputname = os.path.join(sphinx_directory, 'files_list.rst')
    title = component_name.title() + ' files documentation (C/C++ API)\n'
    title += len(title) * '=' + '\n\n'
    with open(outputname, 'wt') as out:
        out.write(title)
        out.write('.. toctree::\n\t:maxdepth: 2\n\n')
        for f in rst_files:
            name = os.path.basename(f).split('.')[0]
            out.write('\t' + name + '\n')

    outputname = os.path.join(sphinx_directory, 'sources_list.rst')
    title = component_name.title() + ' programs listings (C/C++ API)\n'
    title += len(title) * '=' + '\n\n'
    with open(outputname, 'wt') as out:
        out.write(title)
        out.write('.. toctree::\n\t:maxdepth: 2\n\n')
        for f in pgm_files:
            name = os.path.basename(f).split('.')[0]
            out.write('\t' + name + '\n')


def xml2rst(headername, srcdir, component_name, sphinx_directory, doxyconf):
    """Generate rst file(s) from xml (doxygen outputs) for given C/C++ header

    Parameters
    ----------
    headername : string
        name of the header (full path)
    srcdir : string
        absolute path to c/c++ sources (CMAKE_SOURCE_DIR)
    component_name : string
         component (numerics, kernel, ...) of interest
         (i.e. breathe project)
    sphinx_directory : string
        directory where rst files will be written
    doxyconf : dict
        dict describing xml/doxy conf.    
    """
    case_sense_names = doxyconf['CASE_SENSE_NAMES']
    xml_path = doxyconf['XML_OUTPUT']
    # First get list of xml files generated from current header by doxygen
    xml_files = get_xml_files(headername, xml_path, case_sense_names)

    # Then, for each xml, write sphinx header.
    # 3 cases : class, struct or file.
    for f in xml_files:
        path = os.path.join(xml_path, f)
        root = ET.parse(path).getroot()
        compounds = root.findall('compounddef')
        refname = sphinxref4headername(headername, srcdir)
        outputname = os.path.basename(headername).split('.')[0]
        if f.find('class') > -1 or f.find('struct') > -1:
            assert len(compounds) == 1
            name, kind = get_xml_compoundname(compounds[0])
            assert kind == 'struct' or kind == 'class'
            label = '.. _' + kind +'_' + name + ':\n\n'
            title = kind.title() + ' ' + name
            lenname = len(title)
            title = label + title + '\n' + lenname * '=' + '\n\n'
            pgm = 'Defined in :ref:`pgm' + refname + '`' + '\n\n'
            gen = title + pgm            
            gen +='.. doxygen' + kind + ':: ' + name + '\n'
            gen += '\t :project: ' + component_name + '\n'

            outputname = kind + os.path.basename(headername).split('.')[0]
            outputname = os.path.join(sphinx_directory, outputname + '.rst')

        elif f.find('_8h') > -1:
            label = '.. _file' + refname + ':\n\n'
            shortname = headername.split(srcdir)[-1]
            if shortname[0] == '/':
                shortname = shortname[1:]
            title = 'File ' + shortname
            lenname = len(title)
            title = label + title + '\n' + lenname * '=' + '\n\n'
            pgm = ':ref:`Go to the source code of this file <pgm' + refname + '>`' + '\n\n'
            gen = title + pgm
            sphinx_root = os.path.join(sphinx_directory, '../../')
            #relpath = os.path.relpath(srcdir, sphinx_root)
            #fname = os.path.join(relpath, shortname[1:])
            gen += '.. doxygenfile:: ' + shortname + '\n'
            gen += '\t :project: ' + component_name + '\n'
            outputname = 'file_' + os.path.basename(headername).split('.')[0]
            outputname = os.path.join(sphinx_directory, outputname + '.rst')
            
        with open(outputname, 'wt') as out:
            out.write(gen)
            out.write('\n')
            
    create_rst_for_program(headername, srcdir, sphinx_directory, True)
            
def create_rst_for_program(headername, srcdir, sphinx_directory, filterdox=False):
    """
    Parameters
    ----------
    headername : string
        name of the header (full path)
    srcdir : string
        absolute path to c/c++ sources (CMAKE_SOURCE_DIR)
    sphinx_directory : string
        directory where rst files will be written
    filterdox : boolean
        true to remove doxygen comments from program listings in sphinx
    """
    shortname = headername.split(srcdir)[-1]
    outputname = 'pgm_' + os.path.basename(headername).split('.')[0]
    outputname = os.path.join(sphinx_directory, outputname + '.rst')
    refname = sphinxref4headername(headername, srcdir)
    
    title = 'Program listing for file ' + shortname
    label = '.. _pgm' + refname + ':\n\n'
    lenname = len(title)
    title = label + title + '\n' + lenname * '=' + '\n\n'
    doc = '* Return to documentation for :ref:`this file<file' + refname + '>`\n\n'

    gen = title + doc
    if filterdox:
        d = filter_comments(headername)
        gen += '.. code-block:: cpp\n'
        gen += '\t:linenos:\n\n'
        for line in d:
            gen += '\t' + line
    else:
        gen += '.. literalinclude:: /../' + shortname + '\n'
        gen += '\t:language: cpp\n\n'

    with open(outputname, 'wt') as out:
        out.write(gen)

def get_xml_compoundname(compound):
    """Returns object (class, struct ...) name and kind
    from an xml node (compound)
    """
    kind = compound.attrib['kind']
    names = compound.findall('compoundname')
    assert len(names) == 1
    return names[0].text, kind

def sphinxref4headername(headername, srcdir):
    """Returns the reference to set in sphinx for a given file name
    
    Parameters
    ----------
    headername : string
        name of the input file (full path)
    srcdir : part of the name to remove from ref (usually CMAKE_SOURCE_DIR)

    
    """
    refname = headername.split(srcdir)[-1]
    refname = refname.replace('/', '_')
    return refname

    
def filter_comments(headername):
    """Returns list of lines from a
    source file, without doxygen comments.
    """
    with open(headername) as ff:
        # remove doxygen comments lines
        conf = [n for n in ff.readlines() if (not n.lstrip().startswith('/*') and not n.lstrip().startswith('*'))]
        return conf


def find_doxygen_diagrams(doxygen_path, output_directory):
    """Python utility to create sphinx rst file from png generated
    by doxygen (class diagrams ...)

    - scan doxygen ouput (html) path
    - create an image entry for each class_inh*.png file in a rst file

    Parameters
    ----------
    doxygen_path : string
       directory (full path) which contains png files generated by doxygen
    output_path : string
       directory (fullpath) of the rst output
    """
    
    # Scan doxygen output path and create a list with
    # files matching requirements
    class_diagram_match = 'inherit_graph*.png'

    header = '.. _api_class_diagrams:\n\n'
    header += 'C++ Class diagrams\n'
    header += len(header) * '=' + '\n\n'

    files = glob.glob(os.path.join(doxygen_path, class_diagram_match))
    # we need relative paths for sphinx ...
    print("ff", files)
    realfiles = [f.split(doxygen_path)[1] for f in files]
    print(realfiles)
    realfiles = ['/..' + f for f in realfiles]
    outputfile = os.path.join(output_directory, 'class_diagrams.rst')
    with open(outputfile, 'w') as file:
        file.writelines(header)
        #params = [':height: 190 px', ':class: gallery']
        params = [':class: gallery']
        img_prefix = '.. image:: '

        for f in realfiles :
            line = img_prefix + f
            for p in params:
                line += '\n\t' + p
            line += '\n\n'
            file.writelines(line)
