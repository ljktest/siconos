#!/usr/bin/env python

# Siconos-Kernel version @VERSION@, Copyright INRIA 2005-2010.
# Siconos is a program dedicated to modeling, simulation and control
# of non smooth dynamical systems.	
# Siconos is a free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# Siconos is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Siconos; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# Contact: Vincent ACARY, siconos-team@lists.gforge.inria.fr

import os
import sys
import shutil
import platform
import subprocess
import getopt
import tempfile

numerics_prefix = os.getenv('NUMERICSPATH',
                            default='@SiconosNumerics_LIBRARY_DIRS_DIR@')
kernel_prefix = os.getenv('SICONOSPATH',
                          default='@CMAKE_INSTALL_PREFIX@')

msvc = '@MSVC@' != ''
exec_ = True
comp = True
myname = sys.argv[0]
call_pwd = os.getcwd()


# a context manager for a workdir that may be temporary
class WorkDir():
    def __init__(self, directory, tmp=False):
        self.directory = directory
        self.tmp = tmp

    def __enter__(self):

        if self.tmp:
            self.name = tempfile.mkdtemp()
            return self.name

        else:
            if not os.path.exists(self.directory):
                os.makedirs(self.directory)
            return self.directory

    def __exit__(self, xtype, value, traceback):

        if self.tmp:
            shutil.rmtree(self.name)


def silent_try(command, *_args):
    try:
        command(*_args)
    except Exception as e:
        sys.stderr.write('{0} : {1}'.format(myname, e))


def cartridge():
    sys.stdout.write(
"""
|=============================================================================|
|          Siconos-Kernel version @VERSION@, Copyright INRIA 2005-2010.         |
|                                                                             |
|                 Free software under GNU General Public License.             |
|=============================================================================|
""")


def usage():
    sys.stdout.write(
"""
The siconos command compiles, links and runs a Siconos program.

Usage: {0} [options] [YourExample.cpp|location/YourExample.cpp] [Arguments]


 --> To use other source files (*.c, *.cpp, *.f), put them in ./src or
     -see option src_dir below

 --> To create a library and link it with the siconos program, create
    a ./plugin directory or use -plugin_dir option below.

 --> To create some libraries and link them with the siconos program,
     create a ./plugins directory or use -plugins_dir option below.

Options are:

 -a : to find and compile all sources files in YourExample.cpp
      directory.

 -build_dir <dir> : build is done in <dir>. Under /tmp, a temp
                    directory is created


 -clean_build : clean build directory.

 -c | -clean : to clean the current directory (deletes binary files,
               etc.).

 -D key | -D key=value : to define a 'cmake' and a 'cpp' variable.

 -g : to compile with debug informations.

 -h | -help : to print this help.

 -j<n>   : parrallel compilation with n jobs

 -L<dir> : add directory <dir> to the list from with the linker search
           for libraries.

 -l<lib> : link with library <lib>.

 -noexec : compile only.

 -nocomp : execute only.

 -O<n> : set compiler optimization.

 -opt <opt> : add option <opt> to compiler.

 -ldopt <opt> : add option <opt> to linker.

 -P prefix_command : to add a prefix command (time, valgrind, gdb,
                     etc.).


 -plugin_dir <plugin_directory> (default = plugin): create
    <plugin_directory>.so with plugin sources under
    <plugin_directory>.


 -plugins_dir <plugins_directory> (default = plugins): for each source
    file <name_src>.[c|f|cpp] under <plugins_directory> it creates a
    plugin <name_src>.so


 -src_dir <source_directory> (default = src): all sources files under
    <source_directory> (Warning: absolute path!!)  to the executable.

 -v : to print 'make' commands as they are executed.
 """.format(myname))


if __name__ == '__main__':

    cartridge()

    try:
        opts, args = getopt.gnu_getopt(sys.argv[1:], 'acghO:I:j:l:L:D:P:v',
                                       ['build-dir=', 'clean-build', 'clean',
                                        'help', 'noexec', 'nocomp', 'src-dir=',
                                        'opt=', 'ldopt=', 'plugin-dir=',
                                        'plugins-dir='])
    except (getopt.GetoptError, err):
        sys.stderr.write('{0} : {1}\n'.format(myname, str(err)))
        usage()
        exit(2)

    if len(args) == 0:
        usage()
        exit(1)

    definitions = []
    linker_libraries = []
    linker_directories = []
    linker_options = []
    exec_prefix = []
    compiler_options = []
    plugin_directories = []
    plugins_directories = []
    plugins_sources = []
    sources_directories = []
    tmp_build = False
    build_directory = '.siconos'
    clean_build = False
    all_srcs = False
    main_source = None
    make_targets = ['install']
    make_args = []

    for o, a in opts:

        if o == '-a':
            all_srcs = True

        if o == '--build-dir':
            if os.path.commonprefix([a, '/tmp']) == '/tmp':
                tmp_build = True
            build_directory = a

        if o == '--clean-build':
            tmp_build = True

        if o == '-c' or o == '--clean':
            make_targets = ['clean']
            clean_build = True
            exec_ = False

        if o == '-D':
            definitions.append(a)

        if o == '--g':
            definitions.append('CMAKE_BUILD_TYPE=Debug')

        if o == '-h' or o == '--help':
            usage()
            exit(0)

        if o == '--noexec':
            exec_ = False

        if o == '--nocomp':
            comp = False

        if o == '-I':
            compiler_options.append('-I{0}'.format(a))

        if o == '-j':
            make_args.append('-j{0}'.format(a))

        if o == '-l':
            linker_libraries.append(a)

        if o == '-L':
            linker_directories.append(a)

        if o == '-P':
            exec_prefix.append(a)

        if o == '-O':
            compiler_options.append('-O{0}'.format(a))

        if o == '--opt':
            compiler_options.append(a)

        if o == '--ldopt':
            linker_options.append(a)

        if o == '--plugin-dir':
            plugin_directories.append(a)

        if o == '--plugins-dir':
            plugins_directories.append(a)

        if o == '--src-dir':
            all_srcs = True
            sources_directories.append(a)

        if o == '-v':
            make_args.append('VERBOSE=1')

    siconos_build_dir = os.getenv('SICONOS_BUILD_DIR', default=build_directory)

    with WorkDir(directory=siconos_build_dir, tmp=tmp_build) as work_dir:

        # work_dir may be siconos_build_dir or a temp directory if
        # tmp_build is True
        try:
            os.chdir(work_dir)

        except (OSError, e):
            sys.stderr.write('{0} : {1}\n'.format(myname, str(e)))
            exit(2)

        assert(len(args) > 0)
        main_source = os.path.join(call_pwd, args[0])
        exe = os.path.splitext(os.path.basename(main_source))[0]

        if 'install' in make_targets:

            plugin_directories = \
                [os.path.join(call_pwd, d) for d in plugin_directories]

            plugins_directories = \
                [os.path.join(call_pwd, d) for d in plugins_directories]

            if len(sources_directories) == 0:
                if all_srcs:
                    sources_directories = [os.path.dirname(main_source)]

            full_definitions = []
            kwd_definitions = []
            for d in definitions:
                if '=' not in d:
                    full_definitions.append('{0}=1'.format(d))
                    kwd_definitions.append(d)
                else:
                    full_definitions.append(d)
                    kwd_definitions.append(d.split('=')[0])

            extra_defs = ['-D{0}'.format(d) for d in full_definitions]
            all_extra_defs = kwd_definitions

            if comp:
                # for macos : the linker doesn't allow undefined
                # symbol by default -- xhub
                if 'Darwin' in platform.uname():
                    linker_options.append('-undefined', 'dynamic_lookup')
                if msvc:
                    linker_options.append('/FORCE')
                try:
                    subprocess.check_call([
                        'cmake', os.path.join(kernel_prefix,
                                              'share',
                                              'siconos-kernel'),
                        '-DCALL_PWD={0}'.format(call_pwd),
                        '-DMAIN_SOURCE={0}'.format(main_source),
                        '-DPLUGINS_SOURCES={0}'.format(plugins_sources),
                        '-DPLUGINS_DIRECTORIES={0}'.format(
                            ';'.join(plugins_directories)),
                        '-DSOURCES_DIRECTORIES={0}'.format(
                            ';'.join(sources_directories)),
                        '-DCOMPILER_OPTIONS={0}'.format(
                            ';'.join(compiler_options)),
                        '-DCOMMAND_LINE_LINKER_OPTIONS={0}'.format(
                            ';'.join(linker_options)),
                        '-DLINKER_DIRECTORIES={0}'.format(
                            ';'.join(linker_directories)),
                        '-DLINKER_LIBRARIES={0}'.format(
                            ';'.join(linker_libraries)),
                        '-DALL_EXTRA_DEFINITIONS={0}'.format(
                            ';'.join(all_extra_defs)),
                        '-DCMAKE_INSTALL_PREFIX={0}'.format(kernel_prefix)] +
                        extra_defs)
                except Exception as exception:
                    sys.stderr.write(
                        '{0}: {1} build configuration failed, {2}\n'.format(
                            myname, exe, exception))
                    exit(1)

        if comp:
            try:
                assert(len(make_targets) > 0)
                build_command = ['cmake', '--build', '.',
                                 '--target', make_targets[0], '--'] + make_args
                subprocess.check_call(build_command)
            except Exception as exception:
                sys.stderr.write('{0}: {1} build failed, {2}\n'.format(myname,
                                                                     exe,
                                                                     exception))
                exit(1)

    # execution
    if exec_:
        os.chdir(call_pwd)
        env = os.environ
        env['LD_LIBRARY_PATH'] = \
            '{0}:{1}/lib:{2}/lib:{2}/share/siconos-kernel:.'.\
            format(os.getenv('LD_LIBRARY_PATH'),
                   numerics_prefix,
                   kernel_prefix)
        try:
            subprocess.check_call(exec_prefix +
                                  [os.path.join('.', exe)] +
                                  args[1:])
        except Exception as exception:
            sys.stderr.write('{0}: {1} failed, {2}\n'.format(myname,
                                                           exe,
                                                           exception))
            exit(1)
