 This section is devoted to the implementation and the study  of the algorithm. The interval of integration is $[0,T]$, $T>0$, and a grid $t_{0}=0$, $t_{k3+1}=t_{k}+h$, $k \geq 0$, $t_{N}=T$ is constructed. The approximation of a function $f(\cdot)$ on $[0,T]$ is denoted as $f^{N}(\cdot)$, and is a piecewise constant function, constant on the intervals $[t_{k},t_{k+1})$. We denote $f^{N}(t_{k})$ as $f_{k}$. The time-step is $h>0$. \subsection{Time--discretization of the general case~(\ref{eq:quatre}) } This fully general case is not yet implemented in Siconos.Starting from  (\ref{eq:quatre}), let us introduce anew notation, \begin{equation}\begin{array}{l}\dot{x}(t) = f(x(t),t) + r(t)  \\[2mm]y(t) = h(t,x(t),\lambda (t)) \\[2mm]r(t) = g(t,x(t),\lambda (t) ) \\[2mm]\end{array}\label{sept-bis-bis}\end{equation}where $s(t) \in \RR^m$  and $y(t) \in \RR^m$ are  complementary variables related trough the $Sgn$ multi-valued mapping.   According to the class of systems (\ref{eq:deux}), (\ref{eq:trois}) or (\ref{eq:quatre}) , we are studying, the function $f$ and $g$ are defined by a fully nonlinear framework or by affine functions. We have decided to present the time-discretization in its full generality and specialize the algorithms for each cases in Section~\ref{Sec:Spec}.Let us now proceed with the time discretization of (\ref{sept-bis-bis}) by a fully implicit scheme : \begin{equation}  \begin{array}{l}    \label{eq:toto1}     x_{k+1} = x_{k} +h\theta f(x_{k+1},t_{k+1})+h(1-\theta) f(x_k,t_k) + h \theta _r r(t_{k+1})     + h(1-\theta _r)r(t_k)  \\[2mm]     y_{k+1} =  h(t+1,x_{k+1},\lambda _{k+1}) \\[2mm]     r_{k+1} = g(x_{k+\theta},\lambda_{k+1},t+1)\\[2mm]  \end{array}\end{equation}where $\theta = [0,1]$ and $\theta _r \in [0,1]$. As in \cite{acary2008}, we call the problem \eqref{eq:toto1} the ``one--step nonsmooth problem''. This time-discretization is slightly more general than a standard implicit Euler scheme. The main discrepancy lies in the choice of a $\theta$-method to integrate the nonlinear term. For $\theta=0$, we retrieve the explicit integration of the smooth and  single valued term $f$. Moreover for $\gamma =0$, the term $g$ is explicitly evaluated. The flexibility in the choice of $\theta$ and $\gamma$ allows the user to improve and control the accuracy, the stability and the numerical damping of the proposed method. For instance, if the smooth dynamics given by $f$ is stiff, or if we have to use big step sizes for practical reasons, the choice of $\theta > 1/2$ offers better stability with the respect to $h$.\subsection{Newton's linearization}Due to the fact that  two of the  studied classes of systems that are studied in this paper are affine functions in terms of $f$ and $g$, we propose to solve the "one--step nonsmooth problem'' (\ref{eq:toto1}) by performing an external Newton linearization, which yields a Mixed Linear Complementarity Problems (MLCP). \paragraph{Newton's linearization} The first line of the  problem~(\ref{eq:toto1}) can be written under the form of a residue $\mathcal R$ depending only on $x_{k+1}$ and $r_{k+1}$ such that \begin{equation}  \label{eq:NL3}  \mathcal R (x_{k+1},r _{k+1}) =0\end{equation}with $\mathcal R(x,r) = x - x_{k} -h\theta f( x , t_{k+1}) - h(1-\theta)f(x_k,t_k) - h\theta _r r- h(1-\theta_r)r_k$.The solution of this system of nonlinear equations is sought as a limit of the sequence $\{ x^{\alpha}_{k+1},r^{\alpha}_{k+1} \}_{\alpha \in \NN}$ such that \begin{equation}   \label{eq:NL7}   \begin{cases}     x^{0}_{k+1} = x_k \\ \\     \mathcal R_L( x^{\alpha+1}_{k+1},r^{\alpha+1}_{k+1}) = \mathcal     R(x^{\alpha}_{k+1},r^{\alpha}_{k+1})  + \left[ \nabla_{x} \mathcal     R(x^{\alpha}_{k+1},r^{\alpha}_{k+1})\right] (x^{\alpha+1}_{k+1}-x^{\alpha}_{k+1} ) +     \left[ \nabla_{x} \mathcal R(x^{\alpha}_{k+1},r^{\alpha}_{k+1})\right] (r^{\alpha+1}_{k+1} - r^{\alpha}_{k+1} ) =0 \end{cases}\end{equation}The residu free is also defined (useful for implementation only):\[\mathcal R _{free}(x) =  x - x_{k} -h\theta f( x , t_{k+1}) - h(1-\theta)f(x_k,t_k)\]\[\mathcal R (x,r) = \mathcal R _{free}(x)   - h\theta _r r - h(1-\theta_r)r_k\]\[ \mathcal R^{\alpha}_{k+1} = \mathcal R (x^{\alpha}_{k+1},r^{\alpha}_{k+1}) = \mathcal R_{free}(x^{\alpha}_{k+1},r^{\alpha}_{k+1} )  - h\theta _r r^{\alpha}_{k+1} - h(1-\theta_r)r_k\]\[ \mathcal R _{free k+1} ^{\alpha} = \mathcal R_{free}(x^{\alpha}_{k+1},r^{\alpha}_{k+1} )=x^{\alpha}_{k+1} - x_{k} -h\theta f( x^{\alpha}_{k+1} , t_{k+1}) - h(1-\theta)f(x_k,t_k)\] The computation of the Jacobian of $\mathcal R$ with respect to $x$, denoted by $M(x,\lambda)$ leads to \begin{equation}   \label{eq:NL9}   \begin{array}{l}    M^{\alpha}_{k+1}= \nabla_{x} \mathcal R (x^{\alpha}_{k+1},r^{\alpha}_{k+1})= I - h  \theta \nabla_{x} f(  x^{\alpha}_{k+1}, t_{k+1} ).\\ \end{array}\end{equation}At each time--step, we have to solve the following linearized problem,\begin{equation}   \label{eq:NL10}    \mathcal R^{\alpha}_{k+1} + M^{\alpha}_{k+1} (x^{\alpha+1}_{k+1} -    x^{\alpha}_{k+1}) - h \theta _r (r^{\alpha+1}_{k+1} - r^{\alpha}_{k+1} )  =0 ,\end{equation}that is\begin{equation}   \begin{array}{l} h \theta _r  r^{\alpha+1}_{k+1} = r_c + M^{\alpha}_{k+1} x^{\alpha+1}_{k+1} .\label{eq:NL11}  \end{array}\end{equation}with \begin{equation}   \begin{array}{l}r_c = h \theta _r r^{\alpha}_{k+1} - M^{\alpha}_{k+1} x^{\alpha}_{k+1} + \mathcal R^{\alpha}_{k+1}=- M^{\alpha}_{k+1} x^{\alpha}_{k+1} + \mathcal R_{free k+1} ^{\alpha} - h(1-\theta_r)r_k\\ \\\mathcal R ^{\alpha}_{k+1}= x^{\alpha}_{k+1} - x_k -h \theta f(x^{\alpha}_{k+1})-h(1-\theta)f(x_k)- h \theta _r r^{\alpha}_{k+1} -h(1- \theta _r)r_k \end{array}   \end{equation}The matrix $M$ is clearly non singular for small $h$.The same operation is performed with the second equation of (\ref{eq:toto1})\begin{equation}   \label{eq:NL9}   \begin{array}{l}      \mathcal R_y(x,y,\lambda)=y-h(t_{k+1},x,\lambda) =0\\ \\      \mathcal R_{Ly}(x^{\alpha+1}_{k+1},y^{\alpha+1}_{k+1},\lambda^{\alpha+1}_{k+1}) = \mathcal      R_{y}(x^{\alpha}_{k+1},y^{\alpha}_{k+1},\lambda^{\alpha}_{k+1}) +      (y^{\alpha+1}_{k+1}-y^{\alpha}_{k+1})- \\ \qquad \qquad      C^{\alpha}_{k+1}(x^{\alpha+1}_{k+1}-x^{\alpha}_{k+1}) - D^{\alpha}_{k+1}(\lambda^{\alpha+1}_{k+1}-\lambda^{\alpha}_{k+1})=0\\       \end{array}\end{equation}$\mathcal R_y(x^{\alpha+1}_{k+1},y^{\alpha+1}_k+1,\lambda^{\alpha+1}_{k+1})$ leading to the following linearized equation\begin{equation}  y^{\alpha+1}_{k+1} =  y^{\alpha}_{k+1}  -\mathcal R^{\alpha}_{yk+1}+ \\  C^{\alpha}_{k+1}(x^{\alpha+1}_{k+1}-x^{\alpha}_{k+1}) +  D^{\alpha}_{k+1}(\lambda^{\alpha+1}_{k+1}-\lambda^{\alpha}_{k+1}). \label{eq:NL11y}\end{equation}with,\begin{equation}     \begin{array}{l}  C^{\alpha}_{k+1} = \nabla_xh(t_{k+1}, x^{\alpha}_{k+1},\lambda^{\alpha}_{k+1} ) \\ \\  D^{\alpha}_{k+1} = \nabla_{\lambda}h(t_{k+1}, x^{\alpha}_{k+1},\lambda^{\alpha}_{k+1}) \end{array}\end{equation}and\begin{equation}\mathcal R^{\alpha}_{yk+1} = y^{\alpha}_{k+1} - h(x^{\alpha}_{k+1},\lambda^{\alpha}_{k+1}) \end{equation}The same operation is performed with the thirdtheta equation of (\ref{eq:toto1})\begin{equation}   \label{eq:NL9}   \begin{array}{l}      \mathcal R_r(r,x,\lambda)=r-g(x,\lambda,t_{k+1}) =0\\ \\      \mathcal R_{L\lambda}(r^{\alpha+1}_{k+1},x^{\alpha+1}_{k+1},\lambda^{\alpha+1}_{k+1}) = \mathcal      R_{rk+1}^{\alpha} + (r^{\alpha+1}_{k+1} - r^{\alpha}_{k+1}) -      K^{\alpha}_{k+1}(x^{\alpha+1}_{k+1} - x^{\alpha}_{k+1})- B^{\alpha}_{k+1}(\lambda^{\alpha+1}_{k+1} -      \lambda^{\alpha}_{k+1})=0\\ \\      r^{\alpha+1}_{k+1} = r_1 +K^{\alpha}_{k+1}x^{\alpha+1}_{k+1} +B^{\alpha}_{k+1} \lambda^{\alpha+1}_{k+1}        \end{array}\end{equation}with,\begin{equation}r_1 = g(x^{\alpha}_{k+1},r^{\alpha}_{k+1},t_{k+1}) - K^{\alpha}_{k+1} x^{\alpha}_{k+1} -B^{\alpha}_{k+1} \lambda^{\alpha}_{k+1}\end{equation}and,\begin{equation}     \begin{array}{l}  K^{\alpha}_{k+1} = \nabla_xg(x^{\alpha}_{k+1},r^{\alpha}_{k+1},t_{k+1})  \\ \\  B^{\alpha}_{k+1} = \nabla_{\lambda}g(x^{\alpha}_{k+1},r^{\alpha}_{k+1},t_{k+1}) \end{array}\end{equation}and the r residue:\begin{equation}\mathcal      R_{rk+1}^{\alpha} = r^{\alpha}_{k+1} - g(x^{\alpha}_{k+1},r^{\alpha}_{k+1},t_{k+1})  \end{equation}Inserting (\ref{eq:NL11}), we get the following linear relation between $x^{\alpha+1}_{k+1}$ and$\lambda^{\alpha+1}_{k+1}$, \begin{equation}   \begin{array}{l}    (M^{\alpha}_{k+1} -h\theta _r K^{\alpha}_{k+1})x^{\alpha+1}_{k+1} = h \theta _r \left[ - \mathcal      R_{rk+1}^{\alpha} +  r^{\alpha}_{k+1} -K^{\alpha}_{k+1} x^{\alpha}_{k+1}+      B^{\alpha}_{k+1} (\lambda^{\alpha+1}_{k+1} - \lambda^{\alpha}_{k+1}) \right] -r_c \\ \\    x^{\alpha+1}_{k+1} =  x_p + h \theta _r (M^{\alpha}_{k+1}- h \theta _r K^{\alpha}_{k+1})^{-1}  B^{\alpha}_{k+1} \lambda^{\alpha+1}_{k+1}    \end{array}\end{equation}with\begin{equation}x_p =  (M^{\alpha}_{k+1} -h \theta _r K^{\alpha}_{k+1})^{-1}  \left[ -r_c + h \theta _r( -\mathcal      R_{rk+1}^{\alpha} +  r^{\alpha}_{k+1} -K^{\alpha}_{k+1} x^{\alpha}_{k+1}-      B^{\alpha}_{k+1} \lambda^{\alpha}_{k+1} \right)]  \end{equation}Case K=0 leads to :\[ x_p = x_{free} + h \theta _r( -\mathcal  R_{rk+1}^{\alpha} +  r^{\alpha}_{k+1} -K^{\alpha}_{k+1} x^{\alpha}_{k+1}-      B^{\alpha}_{k+1} \lambda^{\alpha}_{k+1} ) \]\[      x_{free}=x^{\alpha}_{k+1} + (M^{\alpha}_{k+1})^{-1}(      \mathcal R _{free k+1} ^{\alpha} +h(1-\theta _r)r_k)\]\begin{equation}x_p =  (M^{\alpha}_{k+1} -h \theta _r K^{\alpha}_{k+1})^{-1}  \left[ -r_c + h \theta _r( -\mathcal      R_{rk+1}^{\alpha} +  r^{\alpha}_{k+1} -K^{\alpha}_{k+1} x^{\alpha}_{k+1}-      B^{\alpha}_{k+1} \lambda^{\alpha}_{k+1} \right)]  \end{equation}Inserting (\ref{eq:NL11y}), we get the following linear relation between $y^{\alpha+1}_{k+1}$ and $\lambda^{\alpha+1}_{k+1}$, \begin{equation}   \begin{array}{l} y^{\alpha+1}_{k+1} = y_p + \left[ h \theta _r C^{\alpha}_{k+1} (M^{\alpha}_{k+1}- h \theta _r K^{\alpha}_{k+1})^{-1}  B^{\alpha}_{k+1} + D^{\alpha}_{k+1} \right]\lambda^{\alpha+1}_{k+1}   \end{array}\end{equation}with \begin{equation}y_p = y^{\alpha}_{k+1} -\mathcal R^{\alpha}_{yk+1} + C^{\alpha}_{k+1}(x_p -x^{\alpha}_{k+1}) -D^{\alpha}_{k+1} \lambda^{\alpha}_{k+1} \end{equation}\paragraph{Mixed linear complementarity problem (MLCP)}To summarize, the problem to be solved in each Newton iteration is:\\{  \begin{minipage}[l]{1.0\linewidth}    \begin{equation}      \begin{cases}      \begin{array}[l]{l}        y^{\alpha+1}_{k+1} =   W^{\alpha}_{k+1}  \lambda^{\alpha+1}_{k+1} + b^{\alpha}_{k+1}        \\ \\        -y^{\alpha+1}_{k+1} \in N_{[l,u]}(\lambda^{\alpha+1}_{k+1} ).       \end{array}      \label{eq:NL14}      \end{cases}    \end{equation}  \end{minipage}}with $W\in \RR^{m\times m}$ and $b\in\RR^{m}$ defined by\begin{equation}  \label{eq:NL15} \begin{array}[l]{l}   W^{\alpha}_{k+1} = h \theta _r C^{\alpha}_{k+1} (M^{\alpha}_{k+1}- h \theta K^{\alpha}_{k+1})^{-1}  B^{\alpha}_{k+1} + D^{\alpha}_{k+1} \\   b^{\alpha}_{k+1} = y_p\end{array}\end{equation}The problem~(\ref{eq:NL14}) is equivalent to a Mixed Linear Complementarity Problem (MLCP) which can be solved under suitable assumptions by many linear complementarity solvers such as pivoting techniques, interior point techniques and splitting/projection strategies. The  reformulation into a standard MLCP follows the same line as for the MCP in the previous section. One obtains,    \begin{equation}      \begin{array}[l]{l}        y^{\alpha+1}_{k+1} =   - W^{\alpha}_{k+1}  \lambda^{\alpha+1}_{k+1} + b^{\alpha}_{k+1}        \\ \\        (y^{\alpha+1}_{k+1})_i  = 0 \qquad \textrm{ for } i \in \{ 1..n\}\\[2mm]        0 \leq  (\lambda^{\alpha+1}_{k+1})_i\perp (y^{\alpha+1}_{k+1})_i \geq 0 \qquad \textrm{ for } i \in \{ n..n+m\}\\      \end{array}      \label{eq:MLCP1}     \end{equation}\paragraph{MLCP solvers.} As for MCP, there exists numerous methods to numerically solve MLCP. In the worst case when the matrix $W^{\alpha+1}_{k+1}$ has no special properties, the MCLP can be always solved by enumerative solvers for which various implementation can be found. With positivity, P-matrix  or co-positivity properties, standard methods for LCP\cite{Cottle.Pang.ea1992} can be straightforwardly extended. Among these methods, we can cite the family of projection/splitting methods, interior point methods and semi-smooth Newton methods (see \cite{acary2008} for an overview of various types of methods.).\subsection{The special cases of the  affine  systems~ (\ref{eq:deux}) and ~ (\ref{eq:trois}) }\label{Sec:Spec}In this section, we specify the time--discretization of the fully nonlinear case for the two other classes of systems~(\ref{eq:deux}) and ~(\ref{eq:trois}) and for particular value of $\theta$ and $\gamma$. %\subsection{Algorithms} %We propose in this section two algorithms to sum-up the numerical implementation of the implicit%Euler time--stepping scheme.%The Algorithm~\ref{Algo:EulerSliding-MCP} describes the implementation%with a generic MCP solvers and%The Algorithm~\ref{Algo:EulerSliding-MCLP} describes the  numerical implementation of the algorithm with an external Newton linearization and a MCLP solver.%\begin{algorithm}[htbp]%   \begin{algorithmic}% { \sf %    \REQUIRE System definition: $\sf f, g, h$ %    \REQUIRE $\sf x(0)$ the initial condition%    \REQUIRE $\sf t_0, T$ time--integration interval%    \REQUIRE $\sf h$ time--step %    \REQUIRE $\sf \theta, \gamma$ numerical integration parameters%    \ENSURE  $\sf (\{ x_k\}, \{ s_k\},\{y_k \}), k \in\{1,2, \ldots \}$ %    \STATE $ \sf $%    \STATE $\sf k \leftarrow 0;\quad  x_{0} \leftarrow x(0);\quad \sf y_{0} \leftarrow y(0) =h(x(0));\quad \sf tau_{0} \leftarrow 0 $  %    \STATE //\textit{ Time integration loop}%     \WHILE {$\sf t_k < T$} %         \STATE Solve the MCP~(\ref{eq:MCP5}) for $\sf x_{k+1}, s_{k+1}, y_{k+1}$ with $\sf F, l$ and $\sf u$ given by ~(\ref{eq:MCP3})  and the Jacobian $\nabla_z F(z)$ given by (\ref{eq:JacMCLP}).%         \STATE //\textit{Update}%         \STATE $\sf x_{k} \leftarrow x_{k+1};\quad \sf s_{k} \leftarrow s_{k+1} ;\quad \sf y_{k} \leftarrow y_{k+1} $%         \STATE //\textit{time iteration}%         \STATE $\sf t_{k} \leftarrow t_{k+1};\quad \sf k \leftarrow k+1$%      \ENDWHILE%     \STATE $ \sf$}%   \end{algorithmic}%   \caption{Implicit Euler time-discretization with a generic MCP solver}  % \label{Algo:EulerSliding-MCP}%\end{algorithm}%\begin{algorithm}[htbp]%   \begin{algorithmic}% { \sf %    \REQUIRE System definition: $\sf f, g, h$ %    \REQUIRE $\sf x(0)$ the initial condition%    \REQUIRE $\sf t_0, T$ time--integration interval%    \REQUIRE $\sf h$ time--step%    \REQUIRE $\sf \theta, \gamma$ numerical integration parameters %    \REQUIRE $\sf \varepsilon $ Newton's method tolerance%    \ENSURE  $\sf (\{ x_k\}, \{ \lambda_k\},\{y_k \}), k \in\{1,2, \ldots \}$ %    \STATE $ \sf $%    \STATE $\sf k \leftarrow 0;\quad  x_{0} \leftarrow x(0);\quad \sf y_{0} \leftarrow y(0) =h(x(0));\quad \sf tau_{0} \leftarrow 0 $  %    \STATE $ $%    \STATE //\textit{ Time integration loop}%     \WHILE {$\sf t_k < T$}%         \STATE $\sf \alpha \leftarrow 0;\quad\sf x^0_{k+1} \leftarrow x^0_{k};\quad s^0_{k+1} \leftarrow s^0_{k};\quad \sf y^0_{k+1} \leftarrow y^0_{k} $%        \STATE //\textit{Newton's loop}%          \WHILE {$\sf  \| \mathcal R(x^{\alpha}_{k+1},\lambda^{\alpha}_{k+1} )\|+\| \mathcal R_y(x^{\alpha}_{k+1},\lambda^{\alpha}_{k+1} )\|+\| \mathcal R_r(x^{\alpha}_{k+1},s^{\alpha}_{k+1} )\| > \varepsilon$}  %         \STATE  $\sf M^{-1}(x^{\alpha}_{k+1},s^{\alpha}_{k+1} ) \leftarrow (I - h \theta\nabla_x f(x^{\alpha}_{k+\theta},t_{k+1}) - h \gamma \nabla_x g(t_{k+\theta},x^{\alpha}_{k+\gamma},\lambda^{\alpha}_{k+1})  )^{-1} $.%         \STATE  $\sf W^{\alpha+1}_{k+1} \leftarrow D^{\alpha}_{k+1} -hC^{\alpha}_{k+1}(M^{\alpha}_{k+1})^{-1}B^{\alpha}_{k+1}$%           \STATE  $\sf b^{\alpha+1}_{k+1} \leftarrow y^{\alpha}_{k+1}-\mathcal R_{yk+1}^{\alpha}+%  \left[hC^{\alpha}_{k+1}(M^{\alpha}_{k+1})^{-1}B^{\alpha}_{k+1} - D^{\alpha}_{k+1}\right]%  \lambda^{\alpha}_{k+1} - C^{\alpha}_{k+1}(M^{\alpha}_{k+1})^{-1} \mathcal R_{k+1}^{\alpha} $%           \STATE $ $%           \STATE Solve the MLCP (\ref{eq:MLCP1}) for $\sf y^{\alpha+1}_{k+1}, s^{\alpha+1}_{k+1}$%           \STATE $ $%          \STATE $\sf \lambda^{\alpha}_{k+1} \leftarrow \lambda^{\alpha+1}_{k+1};\quad  y^{\alpha}_{k+1} \leftarrow y^{\alpha+1}_{k+1} $%         \STATE $\sf x^{\alpha}_{k+1}\leftarrow x^{\alpha}_{k+1} - xp^{\alpha}_{k+1}-h(M^{\alpha}_{k+1})^{-1}B^{\alpha}_{k+1}\lambda^{\alpha}_{k+1}$%         \STATE $\sf \alpha \leftarrow \alpha+1$         %         \ENDWHILE%         \STATE //\textit{Update}%         \STATE $\sf x_{k+1}\leftarrow x^{\alpha}_{k+1};\quad \sf \lambda_{k+1} \leftarrow \lambda^{\alpha+1}_{k+1} ;\quad \sf y_{k+1} \leftarrow y^{\alpha+1}_{k+1} $%         \STATE //\textit{time iteration}%         \STATE $\sf t_{k} \leftarrow t_{k+1};\quad \sf k \leftarrow k+1$%      \ENDWHILE%     \STATE $ \sf$}%   \end{algorithmic}%   \caption{Implicit Euler time-discretization with an external Newton loop and a MLCP solver }  % \label{Algo:EulerSliding-MCLP}%\end{algorithm}%In the case of the system~(\ref{eq:deux}) with a affine function $f$ or $\theta =0$, the the MLCP matrix $W$ can be computed before the beginning of the time loop saving a lot of computing effort.  In the case of the system (\ref{eq:trois}) with $\theta=\gamma=0$, the MLCP matrix $W$ can be computed before the beginning of the Newton loop.\clearpage%%% Local Variables: %%% mode: latex%%% TeX-master: "EulerSliding"%%% End: 