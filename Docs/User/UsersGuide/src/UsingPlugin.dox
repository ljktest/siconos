/*! \page doc_usingPlugin Siconos Plug-in Functions

<b>What for? </b>\n
Plug-in system allows users to provide their own functions to describe some specific behavior of existing classes. \n
For example, user can define a function to compute the external forces of a Dynamical System. 

<b> What is a plug-in? </b>

Some classes have pre-defined functions that can be "connected" to external user-defined functions.\n
Thus a plug-in consists in an "extern C" function, written in a specific file, that must be named "xxxPlugin.cpp", xxx being whatever you want. 

<b> What are the available plug-in?</b>

All the plug-in functions are documented in file DefaultPlugin.cpp. There you can find a complete list of the available plug-in, their signature (ie the \b required types of their arguments) and to which class they are linked. \n
At the time, there are plug-in for:
- DynamicalSystems (see \ref doc_dsPlugin).
- Relations (see \ref doc_relPlugIn).

<b> How to write your own plug-in? </b>

Suppose that you want to define your own way to compute the internal forces for a pre-defined Lagrangian Dynamical System, named myDS.

-# Check that a plug-in is available for what you want (ie see DefaultPlugin.cpp).\n
In \ref doc_dsPlugin, you see that this plug-in exists and in DefaultPlugin.cpp you find:  
\code
extern "C" void computeFInt(double time, unsigned int sizeOfq, const double *q, 
			    const double *velocity, double *fInt, unsigned int sizeOfZ, double *z)
{...}
\endcode

-# Create xxxPlugin.cpp file and write your function as an "extern C", using the right signature as given in DefaultPlugin.cpp.\n
Thus, in myPlugin.cpp
\code
extern "C" void myFint(double time, unsigned int sizeOfq, const double *q, 
		       const double *velocity, double *fInt, unsigned int sizeOfZ, double *z)
{
 // work on fInt ...
}
\endcode

-# In the main file, associate your function to the object. This is usually done thanks to function called setComputeXXX. 
\code
myDS->setComputeFIntFunction("myPlugin.so", "myFint");
\endcode

From this point, each time you need to compute the internal forces in myDS, myFint will be called.
\code
myDS->computeFInt(time); // call myFint(...) with current values of q, velocity ...
\endcode

<b> Plug-in parameters</b>\n

As you can notice, in all the plug-in functions, the last argument is the z parameter of the corresponding DynamicalSystem(s). \n
Then, through this variable you can set and/or use some specific parameters in the plug-in function. 

Example:  suppose that you defined a LagrangianDS named lds, and want to set two parameters in the external forces, say \e mu and \e lambda. \n
Then cpp input file looks like:
\code
// In the main file:
double mu , lambda;
// ... give mu and lambda the required values
// ... declare and built your dynamical system
SP::DynamicalSystem lds(new LagrangianDS(...));
// Link with the plug-in function
lds->setComputeFExtFunction("myPlugin.so", "myFExt");


// === First way, with setZ function (copy) ===
// declare and built a SimpleVector of size 2
SimpleVector myZ(2);
myZ(0) = mu;
myZ(1) = lambda;

lds->setZ(myZ);
// In this case, if parameters values are change after this step,
// this won't affect param values inside the dynamical system. 
//
//=== Second way, with setZPtr function (pointer link) ===
// declare and built a pointer to SimpleVector of size 2
SP::SimpleVector myZPtr(new SimpleVector(2));
(*myZPtr)(0) = mu;
(*myZPtr)(1) = lambda;

lds->setZPtr(myZPtr);

// Warning: in that case, from this point any change in parameters
// will affect param value in the dynamical system.
//
// Then in the plug-in file, you have access to the parameter values:
extern "C" void myFExt(double time, unsigned int sizeOfq, double *fExt, unsigned int sizeOfZ, double *z)
{
for(unsigned int i = 0; i<sizeOfq;++i)
   fExt[i] = cos(z[1]*time) + z[0] ;
// this means that Fext = cos(lambda t) + mu
}
\endcode

*/
