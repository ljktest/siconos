/*! \page docSimu Siconos Simulation and related objects

Simulation object is used to describe how a previously defined NonSmoothDynamicalSystem will be computed. \n

So before starting any simulation process, you need to have a complete non smooth dynamical system (roughly some dynamical systems and some interactions), attached to a Model. Then the key points of the Simulation are:
- the description of a time discretisation (see \ref docSimuTD)
- how the dynamical systems are integrate (see \ref docSimuOSI)
- how the non smooth problem is written and solved (see \ref docSimuOSNS)

Above all these points, a global strategy must be defined. At the time, two possibilities exist in Siconos:
- TimeStepping scheme 
- EventDriven algorithm

Those two types are derived classes of the base one, Simulation.

\image html classSimulation.png

Finally to build a Simulation, four steps are required: 
- choose a strategy, the type of the Simulation: build a TimeStepping or an EventDriven object
- build a TimeDiscretisation object
- build one or more OneStepIntegrator objects
- build one or more OneStepNSProblem objects 

and so, the C++ code looks like:
\code
// Prerequisite: 
// a Model*, say m, that holds a NonSmoothDynamicalSystem* named nsds. 
//
// Step 1: choose the strategy, build the Simulation and link it to the Model
TimeStepping * s = new TimeStepping(m); 
// or
EventDriven * s = new EventDriven(m);

// Step 2: the time discretisation, linked with the Simulation when built. 
TimeDiscretisation * td = new TimeDiscretisation(...,s)

// Step 3: OneStepIntegrators; applied to DynamicalSystems that belong to nsds.
Moreau * integrator = new Moreau(someDS,...,s) ; 
// or
Lsodar * integrator = new Lsodar(someDS,s);

// Step 4: OneStepNSProblems; applied to all the Interactions of the nsds.
OneStepNSProblem * lcp = new LCP(s, ...)
\endcode
Then, from this point the Model is complete and the simulation process can start. Its development depends strongly on the chosen strategy and will then be detailed in the corresponding sections (see \ref docSimuMoreauTS or \ref docSimuED).\n

Warning: it is important to make a clear difference between the building of the Simulation, which is part of the Model, and the computation process which consists mainly in some calls to specific functions of the Simulation. 

\section docSimuIntro Main components of a Simulation
\subsection docSimuTD Time Discretisation

The discretisation scheme is characterized by a vector of size nSteps+1, denoted tk, that handles the values at each time-step, nSteps being the number of time steps. At the time, only a constant time-step (denoted h) time discretisation is available. \n

A TimeDiscretisation must be linked to one and only one Model (required parameter of any constructor). This Model provides the initial time value and possibly the final time value, which is an optional parameter. Thus depending on the constructor you use, you may need to give the time-step, the final time ... \n
Just take care to avoid redundant or conflicting information. See the constructors list in the TimeDiscretisation class documentation for full details. 

Example: 
\code

SP::Model m(new Model(t0)); // only initial time is provided
double h = ...;
unsigned int nSteps = ...;
SP::TimeDiscretisation td(new TimeDiscretisation(h, nSteps,m));
// tk and final time will be automatically computed. 
// 
// Then a simulation is created and associated to m through td. 
SP::Simulation s(new TimeStepping(td));
\endcode

\subsection docSimuOSI One Step Integrators

The OneStepIntegrator ("OSI") class defines the way some dynamical systems will be integrated over a time-step or between two events. \n

At the time, two types of integrators are available in the platform. Each of them corresponds to a specific simulation strategy
- Moreau (see details in \ref docSimuMoreauTS), for time-stepping simulations \n
- Lsodar, for event-driven simulations (see \ref docSimuED). \n

To build an OSI, you need to provide a set of DynamicalSystems (and possibly a set of Interactions) and some specific values depending on the type of the integrator.
Moreover, the "size of the memory" (variable sizeMem) can be set: it concerns the number of time steps for which states values are saved, but at the time no multi-steps integrators are available in Siconos, so keep default value, 1.

Main functions are:

- integrate(tinit, tend,tout ...): to integrate the systems between tinit and tend with a possible stop at tout.
- updateState(...): to compute dynamical systems states values.

\subsubsection docSimuOSIMoreau Moreau
Integration thanks to a theta-method. See \ref docSimuMoreauTS for a full description. 

Main variables: \f$ \theta \f$ (a double) and \f$ W \f$ (a matrix of double). One value of each parameter is attached to each DynamicalSystem concerned by the OSI through a map (STL). For example:
\code
// allDS is a set of DynamicalSystems : ds1, ds2 ...
// s is a Simulation*
SP::Moreau integrator(new Moreau(allDS, 0.5, s));
// all values of theta are initialized to 0.5

double theta = integrator->getTheta(ds1);
// returns the value of theta for the dynamical system ds1.

SP::SiconosMatrix W(integrator->getW(ds1));
// W is a SP::SimpleMatrix, that represents the W linked to ds1. 
\endcode 

\subsubsection docSimuLsodar Lsodar
This class is an interface for LSODAR, odepack integrator (see http://www.netlib.org/alliant/ode/doc). \n
"Lsodar solves problems dy/dt = f with full or banded Jacobian and automatic method selection, and at the same time, it finds the roots of any of a set of given functions of the form g(t,y).  This is often useful for finding stop conditions or points at which switches are to be made in the function f". \n
In Siconos, Lsodar is used for EventDriven algorithm, to integrate the dynamics with stops at new non-smooth events (violation of a constraint). 
That will be detailed in \ref docSimuED. 

Construction:
\code
// allDS is a set of DynamicalSystems and s a SP::Simulation
SP::Lsodar integrator(new Lsodar(allDS,s));
\endcode
At the time, all specific parameters of Lsodar are set by default, but you can set them thanks to set functions. See Lsodar class doxygen documentation for details.

\subsection docSimuOSNS One Step Non Smooth Problems

Considering a set of Interactions, the role of the OneStepNSProblem ("OSNS") is to write in a "pleasant" form the non smooth problem and then to solve it. So, the main variables of this class are:
- a type: the form of the problem, LCP, FrictionContact, QP and Relay (the two last ones are not fully implemented and so not usable).
- a set of Interactions (actually a link to those of the previously built NonSmoothDynamicalSystem)
- a solver
\subsubsection docSimuSolvers Non smooth solvers
Solvers algorithms are implemented in Numerics package and Kernel Solver class is just an interface to those algorithms. The possible solvers are:
- LexicoLemke (maxIter)
- NLGS (Non Linear Gauss Seidel) (tolerance, maxIter)
- NSQP (Non Smooth Quadratic Programming) (tolerance)
- QP   (tolerance)
- CPG  (Conjugate Projected Gradient) (tolerance, maxIter)
- Latin (tolerance, maxIter, searchDirection)

For each of them, the required parameters are indicated between parenthesis. Their default values are:
- maxIter (maximum number of iterations): 101
- tolerance: 0.0001
- normType: "max"
- searchDir: 0.6

Obviously, depending on the problem type, some solvers fit more than others. 

\subsubsection docSimuLCP LCP formalization and solving

A Linear Complementarity Problem (LCP) is defined by :
\f{eqnarray*}
w =  Mz+q \\
w \geq 0, z \geq 0,  z^{T} w = 0 
\f}
where \f$ w \in R^{n} \f$  and \f$ z \in R^{n} \f$ are the unknowns and  \f$ M \in R^{n \times n } \f$  and \f$ q \in R^{n} \f$.\n

Thus, "formalizing" a LCP consists in writing M matrix and q vector (functions \link LCP::assembleM() assembleM \endlink and \link LCP::computeQ() computeQ \endlink).

\subsubsection docSimuFriction Friction-Contact Non Smooth Problem

In Siconos, a Friction Contact is written as a LCP like above:
\f{eqnarray*}
w =  Mz+q \\
w \geq 0, z \geq 0,  z^{T} w = 0 
\f}
plus a Coulomb-Friction law. 

\section docSimuEDindexSet Unitary Relations and Index Sets

Warning: reading this section is only useful if you need more understanging and details in EventDriven algorithm.

\b classes: UnitaryRelation, UnitaryRelationsSet

The Simulation class has a specific member named indexSets, which is a vector (STL) of UnitaryRelationsSet. 

\subsection docSimuUR Unitary Relation definition

Remember that each Interaction has two specific local variables, named y (output) and \f$ \lambda \f$, used to define the non-smooth behavior of the system. The size of the Interaction was defined as the one of y vector. 
Roughly speaking y corresponds to a set of constraints applied to the system, like in Linear Relations (LinearTIR) where:
\f$ y = CX + FU + D \lambda + e \f$

In that case, if D is diagonal, the previous set is equivalent to n independent scalar equations, n being the size of the Interaction: 
\f$ y_i = C_i X +F_i U + d_{ii} \lambda_i+e_i \f$

So a model with n Interactions of size one with the n relation \f$ y_i = \cdots \f$ will be equivalent.\n
 But if D is not diagonal, all relations are to be treated all together, in one block. The same think occurs for a friction problem, where the minimum block size is 2 or 3 (for 2 or 3 dimensional friction) because we need to consider normal and tangential part(s) of y. \n

So to avoid confusion during Simulation process, we define UnitaryRelation object, which "cuts" the Interaction and its vectors into the smallest possible blocks. The size of these blocks corresponds to the non-smooth law size. \n

What is important is that during Simulation process we do not handles Interactions but UnitaryRelations. 
From the user point of view, that did not change anything and since Interactions and UnitaryRelations are linked you can goes on using Interactions in a transparent way. But if you intend to use or have a look into IndexSets, you should know what they handle, UnitaryRelations.

\subsection docSimuIndexSets Index Sets definition

As suggested at the end of the previous section, an index set is a set of unitary relations. \n
Thus we define \f$ I_0 \f$ as the sets of all the unitary relations of the system, which more or less corresponds to the set of all the Interactions of the NonSmoothDynamicalSystem. \n
For example, in a contact-problem, that represents all the unilateral constraints 
(active or not). 
The set \f$ I_0 \f$ is saved in the Topology of the NonSmoothDynamicalSystem, and build during Simulation initialization. From this one, we define all the other sets:
\f[ I_i = \{ UR\in I_{i-1} , y_{ur}[i-1] = 0 \} \f]
with UR=UnitaryRelation, and \f$ y_{ur}[i-1] \f$ the i-1 derivative of the relation of ur. 

\section docSimuTypes Simulation types and process 

\subpage docSimuMoreauTS

\subpage docSimuED

*/
